<doc title="Euphoria To C Translator">

<h1>Euphoria To C Translator</h1>

<ol>
	<li><a href="e2c.htm#intro"> Introduction</a></li>
    <li><a href="e2c.htm#compsupp">C Compilers Supported</a></li>
	<li><a href="e2c.htm#howtorun">How to Run the Translator</a></li>
	<li><a href="e2c.htm#dynamic">Dynamic Link Libraries (Shared Libraries)</a></li>
	<li><a href="e2c.htm#size">Executable Size and Compression</a></li>
	<li><a href="e2c.htm#invstr">Interpreter vs. Translator</a></li>
	<li><a href="e2c.htm#legal">Legal Restrictions</a></li>
	<li><a href="e2c.htm#faq">Frequently Asked Questions</a></li>
	<li><a href="e2c.htm#common">Common Problems</a></li>
</ol>

<h2>Introduction</h2>

 <p><font color="#006633"><b>The Euphoria to C Translator will translate any Euphoria program into equivalent C source code.</b></font></p>
 
 <p>There are versions of the translator for <font color="#CC3366"><b>Windows</b></font>, <font color="#CC3366"><b>DOS</b></font>, <font color="#CC3366"><b>Linux</b></font> and <font color="#CC3366"><b>FreeBSD</b></font>. After translating a Euphoria program to C, you can compile and link using one of the supported C compilers. This will give you an executable file that will typically run much faster than if you used the Euphoria interpreter.</p>
 
 <p>The translator can translate/compile *itself* into an executable file for each platform. The translator is also used in translating/compiling the front-end portion of the interpreter. The source code for the Translator is in <path>euphoria\source</path>. It's written 100% in Euphoria.</p>
 
<h2>C Compilers Supported</h2>

<p>The <font color="#0066CC"><b>Translator</b></font> currently works with GNU C on <font color="#CC3366"><b>Linux</b></font> or <font color="#CC3366"><b>FreeBSD</b></font>, with either <a href="http://www.openwatcom.org">Watcom C</a> or      <a href="http://www.delorie.com/djgpp/">DJGPP C</a> on <font color="#CC3366"><b>DOS</b></font>, and with either Watcom C, <a href="http://www.cs.virginia.edu/~lcc-win32/">Lcc</a> or <a href="http://www.borland.com/products/downloads/download_cbuilder.html">Borland 5.5</a> on <font color="#CC3366"><b>Windows</b></font>. These are all <b>free</b>  compilers.</p>

<p>GNU C will exist already on your Linux or FreeBSD system. The others can be downloaded from their respective Web sites. For Windows, we strongly recommend Watcom or Borland over Lcc. Lcc is still actively being developed and is getting better, but has some bugs that will make it difficult for you to compile a large Windows program correctly. Watcom and Borland are both rock solid. Watcom usually produces slightly smaller, slightly faster executables, but Borland compiles much faster.</p>
 
<p>The Watcom DOS32 package includes the CauseWay DOS extender and file compressor. CauseWay is now open source and free. You can find out more about it at:</p>
 
<p><a href="http://www.devoresoftware.com">http://www.devoresoftware.com</a></p>

<p><font color="#5500FF"><b>emake.bat</b></font> and <font color="#5500FF"><b>objfiles.lnk</b></font> will link in the CauseWay extender automatically. Other DOS extenders, such as DOS4GW, do not work well with the <font color="#0066CC"><b>Translator</b></font>.</p>
 
 <p>The <font color="#0066CC"><b>Translator</b></font> looks for "WATCOM", "LCC", "BORLAND" or "DJGPP" as either environment variables or directories on your <b>PATH</b>. It will generate an <font color="#5500FF"><b>emake.bat</b></font> file that invokes the appropriate compiler and linker.</p>
 
<h3>Notes:</h3>
 
<ul>
	<li>Unlike Watcom, DJGPP does not map DOS low memory into the same segment as other memory. Machine code routines written for the Watcom-based <font color="#0066CC"><b>Euphoria Interpreter</b></font> or <font color="#0066CC"><b>Translator</b></font> will not work with DJGPP, and will likely crash if they try to access low memory, such as video memory. Euphoria's <font color="#006699"><b>peek()</b></font>, <font color="#006699"><b>poke()</b></font>, <font color="#006699"><b>mem_copy()</b></font>, <font color="#006699"><b>mem_set()</b></font> etc. <i><_ba>will</_ba></i> work correctly, as the <font color="#0066CC"><b>Translator</b></font> uses a special DJGPP macro to access low memory. You can port these machine code routines to DJGPP, but you'll need to consult the DJGPP docs for the possible ways of accessing low memory.</li>
	<li>DJGPP fully supports long filenames for reading, writing and creation. Watcom doesn't support creation.</li>
	<li>The Translator with DJGPP does not support use of the mouse.</li>
	<li>The Allegro graphics library, that we use with DJGPP, seems to be much faster than the Watcom graphics library in many cases.</li>
	<li>DJGPP supports a few more text modes, e.g. 35-line mode.</li>
	<li>DJGPP lets the user abort a program at any time, by typing control-c.</li>
	<li>The Lcc implementation ignores <font color="#006699"><b>lock_file()</b></font> and <font color="#006699"><b>unlock_file()</b></font>. They do nothing.</li>
	<li>The <font color="#0066CC"><b>Translator</b></font> uses Lcc's -O optimization flag in <font color="#5500FF"><b>emake.bat</b></font>. This flag can sometimes add to Lcc's unreliability. If your program doesn't work, try passing -lccopt-off to the command line of ecu/ecw. This will disable the use of the lcc optimization flag.</li>
	<li>Warnings are turned off when compiling with <font color="#5500FF"><b>emake.bat</b></font>. If you turn them on,  you may see some harmless messages about variables declared but not used, labels defined but not used, function prototypes not declared etc.</li>
	<li>On Windows, the Watcom linker might issue a warning that it can't open graph.lib. You can ignore this. graph.lib is not used. There doesn't seem to be an easy way to suppress this message. The latest version of Open Watcom seems to have corrected this.</li>
	<li>With Borland and Lcc, Windows console (text-mode) programs cannot read the F-keys or arrow keys, and you may have to hit the Enter key twice. There is no problem with GUI programs.</li>
	<li>The Microsoft C++ compiler for Windows is not yet supported. However you can probably import the C files generated by <font color="#993333"><b>ecw.exe</b></font>, and the run-time library file for Borland, Lcc or Watcom into a Microsoft project, and compile/link with only minor glitches.</li>
</ul>

<h2>How to Run the Translator</h2>

<p>Running the <font color="#0066CC"><b>Translator</b></font> is similar to running the <font color="#0066CC"><b>Interpreter</b></font>. On DOS you would type:</p>
 
<console>
ec allsorts.ex
-- or  --
ec allsorts
</console>
 
<p>On Windows you would type:</p>

<console>
ecw taskwire.exw
</console>
 
<p>On Linux/FreeBSD you would type:</p>

<console>
ecu qsort.exu
</console>

<p>but instead of running the <path>allsorts.ex</path> program, the <font color="#0066CC"><b>Translator</b></font> will create several C source files. Anyone can run the <font color="#0066CC"><b>Translator</b></font>. It's included in euphoria\bin along with the interpreter. To compile and link the C files, you need to install one of the supported C compilers. The <font color="#0066CC"><b>Translator</b></font> creates a batch file called <font color="#5500FF"><b>emake.bat</b></font>  that does all the compiling and linking steps for you, so you don't actually have to know anything about C or C compilers. Just type:</p>
 
<console>emake</console>

<p>When the C compiling and linking is finished, you will have a file called:</p>
 
<p><path>allsorts.exe</path></p>
 
<p>and the C source files will have been removed to avoid clutter.</p>

<p>When you run allsorts.exe, it should run the same as if you had typed:</p>
 
<p><path>ex allsorts</path></p>
 
<p>to run it with the <font color="#0066CC"><b>Interpreter</b></font>, except that it should run faster, showing reduced times for the various sorting algorithms in euphoria\demo\allsorts.ex.</p>

<p>After creating your executable file, emake removes all the C files that were created. If you want to look at these files, run the translator again and look at the files before running emake.</p>
 
<h3>Note to <platform>Linux</platform> and <platform>FreeBSD</platform> users:</h3>

<p>The files will be called <program>emake</program> and <program>shell</program>, and you type <program>./emake</program> to perform the compiles and link, and <b>./shell</b> to run the shell sort program.</p>
  
<h3>Note to Borland and Lcc users:</h3>

<p>For Borland and Lcc there is no standard environment variable, so the <font color="#0066CC"><b>Translator</b></font> will search your <b>PATH</b> variable looking for a likely
  compiler directory. It looks in standard places such as: ..\LCC, ..\BCC.., ..\Borland.. etc. If you've installed in a nonstandard place you might have to rename your installation directory. To edit your PATH variable on Windows XP, click: Start Menu / Control Panel / Performance and Maintenance / System / Advanced / Environment Variables / User variables for ... Then Select PATH and edit its value. Insert somewhere: C:\BORLAND\BCC55\BIN; or C:\LCC\BIN; Then click OK a couple of times to close the windows. The next DOS window you open should have the new value.</p>
     
<h2>Command-Line Options</h2>

<p>If you happen to have more than one C compiler for a given platform, you can select the one you want to use with a command-line option:</p>
 
	<console>-bor</console>
	<console>-lcc</console>
	<console>-wat</console>
	<console>-djg</console>
	
<p>on the command line to <font color="#993333"><b>ec</b></font> or <font color="#993333"><b>ecw</b></font>. e.g.</p>
 
	<console>ecw -bor pretend.exw</console>

<p>Normally, after building your .exe file, the <b>emake</b> batch file will delete all C files and object files produced by the Translator. If you want <b>emake</b> to keep these files, add the <b>-keep</b> option to the Translator command-line. e.g.</p>
 
	<console>ec -wat -keep sanity.ex</console>

<p>To make a <font color="#CC3366"><b>Windows</b></font> .dll file, or <font color="#CC3366"><b>Linux</b></font> or <font color="#CC3366"><b>FreeBSD</b></font> .so file, just add <_bq>-dll</_bq> to the command line. e.g.</p>
 
	<console>ecw -bor -dll mylib.ew</console>

<p>To make a <font color="#CC3366"><b>Windows</b></font> <b>console</b> program instead of a Windows GUI program, add <_bq>-con</_bq> to the command line. e.g.</p>

	<console>ecw -bor -con myprog.exw</console>
 
<p>To increase or decrease the total amount of stack space reserved for your program, add <_bq>-stack nnnn</_bq> to the command line. e.g.</p>

	<console>ec -stack 100000 myprog.ex</console>
 
<p>The total stack space (in bytes) that you specify will be divided up among all the tasks that you have running (assuming you have more than one). Each task has it's own private stack space. If it exceeds its allotment, you'll get a run-time error message identifying the task and giving the size of its stack space. Most non-recursive tasks can run with call stacks as small as 2000 bytes, but to be safe, you should allow more than this. A deeply-recursive task could use a great deal of space. It all depends on the maximum levels of calls that a task might need. At run-time, as your program creates more simultaneously-active tasks, the stack space allotted to each task will tend to decrease.</p>

<p>When using LCC, sometimes the default optimization causes problems. You can disable this optimization by adding <_bq>-lccopt-off</_bq> to the command line.</p>
 
	<console>ecw -lcc -lccopt-off myprog.exw</console>

<p>To make a <font color="#CC3366"><b>DOS</b></font> program, compiled by WATCOM, that uses fast hardware floating-point instructions, add <_bq>-fastfp</_bq> to the command line. e.g.</p>

	<console>ec -wat -fastfp crunch.ex</console>

<p>By default, Euphoria for DOS calls routines to test if hardware floating-point instructions are available. If they are not, then slower software emulation code is used. When <b>-fastfp</b> is specified, the compiled code will assume the existence of hardware floating-point. This can cause floating-point intensive programs to run about twice as fast, but they will fail to run at all on old 486's and 386's that are lacking hardware floating-point support. With <_bq>-fastfp</_bq>, emake.bat chooses faster WATCOM C compiler options, and emake.bat must also link in <b>ecfastfp.lib</b> instead of ec.lib.</p>
 
<p>On all other platforms, Euphoria uses fast hardware floating-point instructions, and the operating system handles the case where hardware f.p. is missing.</p>
 
<p>To compile your program with debugging information, usable with a debugger compatible with your compiler, use the <b>-debug</b> option:</p>
 
	<console>ecu -debug myapp.exu</console>

<p>It is sometimes useful to link your translated code to a Euphoria runtime library other than the default supplied library.  This ability is probably mostly useful for testing and debugging the runtime library itself, or to give additional debugging information when debugging translated Euphoria code.  Note that only the default library is supplied.  The custom library must be put into your EUDIR/bin directory along with the default library. Use the <b>-lib {library}</b> option:</p>
 
	<console>ecu -lib decu.a myapp.exu</console>
 
<h2>Dynamic Link Libraries (Shared Libraries)</h2>

<p>Simply by adding <_bq>-dll</_bq> to the command line, the <font color="#0066CC"><b>Translator</b></font> will build a <font color="#CC3366"><b>Windows</b></font> .dll (<font color="#CC3366"><b>Linux</b></font>/<font color="#CC3366"><b>FreeBSD</b> </font> .so) file instead of an executable program.</p>

<p>You can translate and compile a set of useful Euphoria routines, and share them with other people, without giving them your source. Furthermore, your routines will likely run much faster when translated and compiled. Both translated/compiled and interpreted programs will be able to use your library.</p>

<p>Only the global Euphoria procedures and functions, i.e. those declared with the "global" keyword, will be exported from the .dll (.so).</p>

<p>Any Euphoria program, whether translated/compiled or interpreted, can link with a Euphoria .dll (.so) using the same mechanism that lets you link with a .dll (.so) written in C. The program first calls <font color="#006699"><b>open_dll()</b></font> to open the .dll or .so file, then it calls <font color="#006699"><b>define_c_func()</b></font> or <font color="#006699"><b>define_c_proc()</b></font> for any routines that it wants to call. It calls these routines using <font color="#006699"><b>c_func()</b></font> and <font color="#006699"><b>c_proc()</b></font>. See <a class="blue" href="library.htm#call_c_func"><b>library.doc</b></a> for the details.</p>

<p>The routine names exported from a Euphoria .dll will vary depending on which C compiler you use.</p>

<p>GNU C on Linux or FreeBSD exports the names exactly as they appear in the C code produced by the <font color="#0066CC"><b>Translator</b></font>, e.g. a Euphoria routine</p>

	<console>global procedure foo(integer x, integer y)</console>

<p>would be exported as "_0foo" or maybe "_1foo" etc. The underscore and digit are added to prevent naming conflicts. The digit refers to the Euphoria file where the symbol is defined. The main file is numbered as 0. The include files are numbered in the order they are encountered by the compiler. You should check the C source to be sure.</p>

<p>Lcc would export foo() as "__0foo@8", where 8 is the number of parameters (2) times 4. You can check the .def file created by the <font color="#0066CC"><b>Translator</b></font> to see all the exported names.</p>

<p>For Borland the <font color="#0066CC"><b>Translator</b></font> also creates a .def file, but this .def file renames the exported symbols back into the same names that you used in your Euphoria source, so foo() would be exported as "foo". </p>

<p>For Watcom the same renaming as with Borland occurs, but instead of a .def file, an EXPORT command is added to <font color="#5500FF"><b>objfiles.lnk</b></font> for each exported symbol.</p>

<p>With Borland and Watcom you can edit the .def or <font color="#5500FF"><b>objfiles.lnk</b></font> file, and rerun <font color="#5500FF"><b>emake.bat</b></font>, to rename the exported symbols, or remove ones that you don't want to export. With Lcc you can remove symbols but you can't rename them.</p>

<p>
Having nice exported names is not critical, since
the name need only appear once in each
Euphoria program that uses the .dll, i.e. 
in a single <font color="#006699"><b>define_c_func()</b></font> or
<font color="#006699"><b>define_c_proc()</b></font>
statement. The author of a .dll should probably provide his users with
a Euphoria include file containing the necessary
<font color="#006699"><b>define_c_func()</b></font>
and <font color="#006699"><b>define_c_proc()</b></font> statements, and he
might even provide a set of Euphoria "wrapper" routines to call the
routines in the .dll.</p>

<p>
When you call <font color="#006699"><b>open_dll()</b></font>, any top-level
Euphoria statements in the
.dll or .so will be executed automatically, just like a normal program. 
This gives the library 
a chance to initialize its data structures prior to the first 
call to a library routine. For many libraries no initialization is
required.</p>

<p>
To pass Euphoria data (atoms and sequences) as arguments, or to receive a
Euphoria object as a result, you will need to use the following 
constants in <font color="#5500FF"><b>euphoria\include\dll.e</b></font>:</p>

<eucode>
      -- Euphoria types for .dll (.so) arguments and return values:
      global constant
		      E_INTEGER = #06000004,
		      E_ATOM    = #07000004,
		      E_SEQUENCE= #08000004,
		      E_OBJECT  = #09000004
</eucode>

<p>Use these in <font color="#006699"><b>define_c_proc()</b></font> and
<font color="#006699"><b>define_c_func()</b></font> just as 
you currently use C_INT, C_UINT etc. to call C .dll's and .so's.</p>

<p>
Currently, file numbers returned by <font color="#006699"><b>open()</b></font>, 
and routine id's returned by <font color="#006699"><b>routine_id()</b></font>,
can be passed and returned,
but the library and the main program each have their own separate 
ideas of what these numbers mean. Instead of passing the file number 
of an open file, you could instead pass the file name and let the 
.dll (.so) open it. Unfortunately there is no simple solution for 
passing routine id's. This might be fixed in the future.</p>

<p>
A Euphoria .dll or .so currently may not execute any multitasking
operations. The Translator will give you an error message about this.</p>

<p>
Euphoria .dlls (.so's) can also be used by 
C programs as long as only 31-bit integer values are exchanged.
If a 32-bit pointer or integer must be passed, and you have the source
to the C program, you could pass the value in two separate 
16-bit integer arguments (upper 16 bits and lower 16 bits), and then combine 
the values in the Euphoria routine into the desired 32-bit atom.</p>

<h2>Executable Size and Compression</h2>

<p>
 On DOS32 with Watcom, if the <font color="#0066CC"><b>Translator</b></font>
 finds the CauseWay files, 
 cwc.exe and le23p.exe in <font color="#5500FF"><b>euphoria\bin</b></font>, it
 will add commands to <font color="#5500FF"><b>emake.bat</b></font> 
 that will compress your executable file. If you don't want compression,
 you can edit <font color="#5500FF"><b>emake.bat</b></font>, or remove or
 rename cwc.exe and/or le23p.exe.</p>
 
 <p>
 On Linux, FreeBSD, Windows, and DOS32 with DJGPP,
 <font color="#5500FF"><b>emake</b></font> does not include a command 
 to compress your executable file. If you want to do this we suggest you 
 try the free UPX compressor. You can get UPX from:</p>
              
<p><a href=http://upx.sourceforge.net>http://upx.sourceforge.net</a></p>
 
<p> Large Win32Lib-based .exe's produced by the Translator can be compressed 
 by UPX to about 15% of their original size, and you won't notice any
 difference in start-up time.</p>
 
 <p>
 The <font color="#0066CC"><b>Translator</b></font> deletes routines that are
 not used, including those from 
 the standard Euphoria include files. After deleting unused routines, it 
 checks again for more routines that have now become unused, and so on. 
 This can make a big difference, especially with Win32Lib-based programs 
 where a large file is included, but many of the included routines are not 
 used in a given program. </p>
 
 <p>
 Nevertheless, your compiled executable file will likely be larger than the
 same Euphoria program bound with the
 interpreter <font color="#0066CC"><b>back-end</b></font>. This is partly due to the 
 <font color="#0066CC"><b>back-end</b></font> being a compressed executable.
 Also, Euphoria statements 
 are extremely compact when stored in a bound file. They need more space 
 after being translated to C, and compiled into machine code. Future 
 versions of the <font color="#0066CC"><b>Translator</b></font> will produce
 faster and smaller executables.</p>

<h2><a name="invstr"></a>Interpreter vs. Translator</h2>

<p>
 All Euphoria programs can be translated to C, and with just a few exceptions
 noted below, will run the same as with the
 <font color="#0066CC"><b>Interpreter</b></font> (but hopefully faster).</p>
 
 <p>
 The <font color="#0066CC"><b>Interpreter</b></font> and
 <font color="#0066CC"><b>Translator</b></font> share the same parser, so
 you will get the same syntax errors, variable not declared errors etc. with
 either one. </p>
 
 <p>
 The <font color="#0066CC"><b>Interpreter</b></font> automatically expands
 the call stack (until memory is exhausted), 
 so you can have a huge number of levels of nested calls.
 Most C compilers, on most systems, have a pre-set limit on the size of
 the stack. Consult your compiler or linker manual if you want to
 increase the limit, for example if you have a recursive routine that
 might need thousands of levels of recursion. Modify the 
 link command in emake.bat. For Watcom C, use 
 <b>OPTION STACK=nnnn</b>, where nnnn is the number of bytes of stack space.</p>
  
 <h3>Note:</h3>

 <p>The <font color="#0066CC"><b>Translator</b></font> assumes
  that your program has no run-time errors in it that would be caught by the
 <font color="#0066CC"><b>Interpreter</b></font>.
 The <font color="#0066CC"><b>Translator</b></font> does not check for:
 subscript out of bounds, variable not initialized, 
 assigning the wrong type of data to a variable, etc.</p>
 
 <p>
 You should <b>debug</b> your program with the
 <font color="#0066CC"><b>Interpreter</b></font>. The Translator checks for
 certain run-time errors, but in the interest of speed, most are not checked.
 When translated C code crashes you'll typically get a very cryptic 
 machine exception. In most cases, the first thing you should do
 is run your program with the <font color="#0066CC"><b>Interpreter</b></font>,
 using the same inputs, and preferably with 
 <font color="#993333"><_bq>type_check</_bq></font> turned on.
 If the error only shows up in translated code, you can use <b>with trace</b>
 and <b>trace(3)</b> to get a <b>ctrace.out</b> file showing a 
 circular buffer of the last 500 Euphoria statements executed. 
 If a translator-detected error message is displayed (and stored in 
 <font color="#5500FF"><b>ex.err</b></font>), 
 you will also see the offending line of Euphoria source whenever <b>with trace</b> 
 is in effect. 
 <b>with trace</b> will slow your program down, and the slowdown can be 
 extreme when <b>trace(3)</b> is also in effect.</p>
  
<h2><a name="legal"></a>Legal Restrictions</h2>

 <p>
 As far as RDS is concerned, any executable programs or .dll's that you create 
 with this <font color="#0066CC"><b>Translator</b></font> without modifying
 an RDS translator library file,  
 may be distributed royalty-free. You are free to incorporate any 
 Euphoria files provided by RDS into your application. </p>
  
 <p>
 In January 2000, the CauseWay DOS extender was donated to the public domain 
 by Michael Devore. He has surrendered his copyright, and encourages anyone 
 to use it freely, including for commercial use.</p>
 
 <p>
 In general, if you wish to use Euphoria code written by 3rd parties, 
 you had better honor any restrictions that apply. If in doubt, you should 
 ask for permission.</p>
 
 <p>
 On Linux, FreeBSD and DJGPP for DOS32, the GNU Library licence will normally 
 not affect programs created with this
 <font color="#0066CC"><b>Translator</b></font>. Simply compiling 
 with GNU C does not give the Free Software Foundation any jurisdiction 
 over your program. If you statically link their libraries you will be 
 subject to their Library licence, but the standard compile/link procedure 
 in <font color="#5500FF"><b>emake</b></font> does not statically link any
 FSF libraries, so there should be no 
 problem.  </p>
 
 <p>
 The Allegro graphics library, used by DJGPP, is referred to as "Giftware"
 in their documentation, and they allow you to redistribute it as part
 of your program. They ask for, but do not require, some acknowledgement.</p>
 
 <h2>Disclaimer:</h2>

<p>This is what we believe to be the case. We are not lawyers.
 If it's important to you, you should read the GNU Library licence, 
 the legal comments in DJGPP, Lcc and Borland, and 
 Michael Devore's read.me file on his site, to form your own judgement.</p>
 
<h2><a name="faq"></a>Frequently Asked Questions</h2>

<h3>How much of a speed-up should I expect?</h3>

<p>It all depends on what your program spends its time doing.
   Programs that use mainly integer calculations, don't call
   run-time routines very often, and don't do much I/O will
   see the greatest improvement, currently up to about 5x faster.
   Other programs may see only a few percent improvement.</p>
 <p>
   The various C compilers are not equal in optimization ability.
   Watcom, GNU C and DJGPP produce the fastest code. Borland is fairly good. 
   Lcc lags slightly behind the others, even when its -O flag is used.</p>
 <p>
   Borland compiles the fastest. Watcom compiles the slowest.</p>
   
<h3>What if I want to change the compile or link options
   in emake.bat?</h3>
   
<p>Feel free to do so, however you should copy
   <font color="#5500FF"><b>emake.bat</b></font> to your own
   file called (say) mymake.bat, then run mymake.bat after running the 
   Translator. Occasionally the number of .c files produced by the 
   Translator could change.</p>

<h3>How can I make my program run even faster?</h3>

<p>It's important to declare variables as integer where possible.
   In general, it helps if you choose the most restrictive type possible
   when declaring a variable.</p>
   <p>
   Typical user-defined types will not slow you down. Since your program
   is supposed to be free of type_check errors, types are ignored by 
   the Translator, unless you call them directly with normal 
   function calls. The one exception is when a 
   user-defined type routine has side-effects (i.e. it sets a global variable,
   performs pokes into memory, I/O etc.). In that case, if
   <font color="#993333"><b>with type_check</b></font> is in effect, the
   Translator will issue code to
   call the type routine and report any type_check failure that results.</p>
   <p>
   On Windows and DOS we have left out the /ol loop optimization
   for Watcom's wcc386. We found in a couple of rare cases that this option
   led to incorrect machine code being emitted by the Watcom C compiler.
   If you add it back in to your own version of <b>emake.bat</b> you might
   get a slight improvement in speed, with a slight risk of buggy code.
   For DJGPP you might try -O6 instead of -O2.</p>
   <p>
   For DOS we use the Watcom /fpc option which generates calls to run-time
   routines to perform floating-point operations. If the machine has
   floating-point hardware it will be used by the routine, otherwise
   software emulation will be used. This slows things down somewhat, 
   and isn't needed on Pentiums, but it guarantees that your program 
   will run on all 386 and 486 machines, even if they lack floating-point 
   hardware. The DOS run-time library,
   <font color="#5500FF"><b>ec.lib</b></font>, was built this way, so 
   you can't simply remove this option. </p>
   <p>
   On Linux or FreeBSD you could try the O3 option of gcc instead of O2. 
   It will "in-line" small routines, improving speed slightly, but creating a 
   larger executable. You could also try the 
    <a href=http://www.intel.com/cd/software/products/asmo-na/eng/compilers/clin/index.htm>
    Intel C++ Compiler for Linux</a>. It's compatible with GNU C, but 
    some adjustments to <b>emake</b> might be required.</p>

<h2><a name="common"></a>Common Problems</h2>

 <p>
 Many large programs have been successfully translated and compiled using
 each of the supported C compilers, and the Translator is now quite
 stable.</p>

 <h3>Note:</h3>
 
<p>On Windows, if you call a C routine that uses
  the cdecl calling convention (instead of stdcall), you must 
  specify a '+' character at the start of the routine's name in
  <font color="#006699"><b>define_c_proc()</b></font> and
  <font color="#006699"><b>define_c_func()</b></font>. 
  If you don't, the call may work when running the
  <font color="#993333"><b>exw</b></font> Interpreter, but will probably
  fail (crash) when you translate and compile with Borland or Lcc.</p>
  
 <p>
 In some cases a huge Euphoria routine is translated to C, and it proves 
 to be too large for the C compiler to process. If you run into this problem, 
 make your Euphoria routine smaller and simpler. You can also try turning 
 off C optimization in <font color="#5500FF"><b>emake.bat</b></font> for just
 the .c file that fails. Breaking 
 up a single constant declaration of many variables into separate 
 constant declarations of a single variable each, may also help. Euphoria 
 has no limits on the size of a routine, or the size of a file, but most 
 C compilers do. The Translator will automatically produce multiple small 
 .c files from a large Euphoria file to avoid stressing the C compiler. 
 It won't however, break a large routine into smaller routines.</p>
  
 <p>
 Post bug reports on EUforum.</p>
 <p>
 In particular, report any program that does not run
 the same when compiled as it does when interpreted.</p>
 
</doc>
