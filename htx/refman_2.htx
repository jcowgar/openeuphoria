<doc title="Euphoria Reference Manual Part I - Section 2">

<h2>Language Definition</h2>

<h3>Objects</h3>

<h4>Atoms and Sequences</h4>

<p>
All data <strong>objects</strong> in Euphoria are either <strong>atoms</strong>
or <strong>sequences</strong>.  An <strong>atom</strong> is a single numeric
value.  A <strong>sequence</strong> is a collection of numeric values.</p>

<p>
The <strong>objects</strong> contained in a sequence can be an arbitrary mix of
atoms or sequences. A sequence is represented by a list of objects in brace
brackets, separated by commas. Atoms can have any integer or double-precision
floating point value. They can range from approximately -1e300 (minus one times
10 to the power 300) to +1e300 with 15 decimal digits of accuracy. Here are
some Euphoria objects:</p>

<eucode>
-- examples of atoms:
0
1000
98.6
-1e6

-- examples of sequences:
{2, 3, 5, 7, 11, 13, 17, 19}
{1, 2, {3, 3, 3}, 4, {5, {6}}}
{{"jon", "smith"}, 52389, 97.25}
{}                        -- the 0-element sequence
</eucode>

<p>
Numbers can also be entered in hexadecimal. For example:
</p>

<eucode>
#FE             -- 254
#A000           -- 40960
#FFFF00008      -- 68718428168
-#10            -- -16
</eucode>

<p>
Only the capital letters A, B, C, D, E, F are allowed in hex numbers.  Hex
numbers are always positive, unless you add a minus sign in front of the #
character. So for instance #FFFFFFFF is a huge positive number (4294967295),
*not* -1, as some machine-language programmers might expect.</p>

<p>
Sequences can be nested to any depth, i.e. you can have sequences within
sequences within sequences and so on to any depth (until you run out of
memory). Brace brackets are used to construct sequences out of a list of
expressions.  These expressions can be constant or evaluated at run-time.
e.g.</p>

<eucode>
{x+6, 9, y*w+2, sin(0.5)}
</eucode>

<p>
The <b>"Hierarchical Objects"</b> part of the Euphoria acronym comes from the
hierarchical nature of nested sequences. This should not be confused with the
class hierarchies of certain object-oriented languages.</p>

<p>
Why do we call them atoms?  Why not just "numbers"? Well, an atom <i>is</i>
just a number, but we wanted to have a distinctive term that emphasizes that
they are indivisible. Of course in the world of physics, atoms were split into
smaller parts many years ago, but in Euphoria you can't split them. They are
the basic building blocks of all the data that a Euphoria program can
manipulate. With this analogy, <strong>sequence</strong>s might be thought of
as "molecules", made from atoms and other molecules. A better analogy would be
that sequences are like directories, and atoms are like files. Just as a
directory on your computer can contain both files and other directories, a
sequence can contain both atoms and other sequences (and <i>those</i> sequences
can contain atoms and sequences and so on).</p>

<p>
As you will soon discover, sequences make Euphoria very simple <i>and</i> very
powerful.  <b>Understanding atoms and sequences is the key to understanding
Euphoria.</b></p>

<dl>
<dt>
<b>Performance Note:</b></dt>

<dd>
Does this mean that all atoms are stored in memory as 8-byte floating-point
numbers? No. The Euphoria interpreter usually stores integer-valued atoms as
machine integers (4 bytes) to save space and improve execution speed. When
fractional results occur or numbers get too big, conversion to floating-point
happens automatically.</dd>

</dl>

<h4>Character Strings and Individual Characters</h4>

<p>
A <strong>character string</strong> is just a <strong>sequence</strong> of
characters.  It may be entered using quotes e.g.</p>

<eucode>
"ABCDEFG"
</eucode>

<p>
Character strings may be manipulated and operated upon just like any other
sequences. For example the above string is entirely equivalent to the
sequence:</p>


<eucode>
{65, 66, 67, 68, 69, 70, 71}
</eucode>

<p>
which contains the corresponding ASCII codes. The Euphoria compiler will
immediately convert "ABCDEFG" to the above sequence of numbers.  In a sense,
there are no "strings" in Euphoria, only sequences of numbers.  A quoted string
is really just a convenient notation that saves you from having to type in all
the ASCII codes.</p>

<p>
<a name=empty_seq></a> It follows that "" is equivalent to {}. Both represent
the sequence of length-0, also known as the <strong>empty sequence</strong>. As
a matter of programming style, it is natural to use "" to suggest a length-0
sequence of characters, and {} to suggest some other kind of sequence.</p>

<p>
<a name=char></a> An <strong>individual character</strong> is an
<strong>atom</strong>.  It must be entered using single quotes. There is a
difference between an individual character (which is an atom), and a character
string of length-1 (which is a sequence). e.g.</p>

<eucode>
'B'   -- equivalent to the atom 66 - the ASCII code for B
"B"   -- equivalent to the sequence {66}
</eucode>

<p>
Again, 'B' is just a notation that is equivalent to typing 66. There aren't
really any "characters" in Euphoria, just numbers (atoms).</p>

<p>
Keep in mind that an atom is <i>not</i> equivalent to a one-element sequence
containing the same value, although there are a few built-in routines that
choose to treat them similarly.</p>

<p>
Special characters may be entered using a back-slash:</p>

<console>
\n        newline
\r        carriage return
\t        tab
\\        backslash
\"        double quote
\'        single quote
</console>

<p>
For example, "Hello, World!\n", or '\\'. The Euphoria editor displays character
strings in green.</p>

<h3>Comments</h3>

<p>
Comments are started by two dashes and extend to the end of the current line.
e.g.</p>

<eucode>
-- this is a comment
</eucode>

<p>
Comments are ignored by the compiler and have no effect on execution speed.
The editor displays comments in red. </p>

<p> 
On the first line (only) of your program, you can use a special comment
beginning with #!, e.g.</p>

<eucode>
#!/home/rob/euphoria/bin/exu  
</eucode>

<p>This informs the Linux shell that your file should be executed by the
Euphoria interpreter, and gives the full path to the interpreter.  If you make
your file executable, you can run it, just by typing its name, and without the
need to type "exu". On DOS and Windows this line is just treated as a comment
(though Apache Web server on Windows does recognize it.). If your file is a
shrouded .il file, use backendu instead of exu.</p>

<h3>Expressions</h3>

<p>
Like other programming languages, Euphoria lets you calculate results by
forming expressions. However, in Euphoria you can perform calculations on
entire sequences of data with one expression, where in most other languages you
would have to construct a loop. In Euphoria you can handle a sequence much as
you would a single number. It can be copied, passed to a subroutine, or
calculated upon as a unit. For example,</p>

<eucode>
{1,2,3} + 5
</eucode>

<p>
is an expression that adds the sequence {1,2,3} and the atom 5 to get the
resulting sequence {6,7,8}.</p>

<p>
We will see more examples later.</p>

<h4>Relational Operators</h4>

<p>
The relational operators  <strong>< &nbsp; > &nbsp; <= &nbsp; >= &nbsp; =
&nbsp; != &nbsp;</strong> each produce a 1 (true) or a 0 (false) result.</p>

<eucode>
8.8 < 8.7   -- 8.8 less than 8.7 (false)
-4.4 > -4.3 -- -4.4 greater than -4.3 (false)
8 <= 7      -- 8 less than or equal to 7 (false)
4 >= 4      -- 4 greater than or equal to 4 (true)
1 = 10      -- 1 equal to 10 (false)
8.7 != 8.8  -- 8.7 not equal to 8.8 (true)
</eucode>

<p>
As we will soon see you can also apply these operators to sequences.</p>

<h4>Logical Operators</h4>

<p>
The logical operators and, or, xor, and not are used to determine the "truth"
of an expression. e.g.</p>

<eucode>
1 and 1     -- 1 (true)
1 and 0     -- 0 (false)
0 and 1     -- 0 (false)
0 and 0     -- 0 (false)

1 or  1     -- 1 (true)
1 or  0     -- 1 (true)
0 or  1     -- 1 (true)
0 or  0     -- 0 (false)

1 xor 1     -- 0 (false)
1 xor 0     -- 1 (true)
0 xor 1     -- 1 (true)
0 xor 0     -- 0 (false)

not 1       -- 0 (false)
not 0       -- 1 (true)
</eucode>

<p>
You can also apply these operators to numbers other than 1 or 0. The rule is:
zero means false and non-zero means true. So for instance:</p>

<eucode>
5 and -4    -- 1 (true)
not 6       -- 0 (false)
</eucode>

<p>
These operators can also be applied to sequences. See below.</p>

<p>
In some cases <a href="refman_2.htm#shortcir">short-circuit</a> evaluation will
be used for expressions containing and or or.</p>

<h4>Arithmetic Operators</h4>

<p>
The usual arithmetic operators are available: add, subtract, multiply, divide,
unary minus, unary plus.</p>

<eucode>
3.5 + 3  -- 6.5
3 - 5    -- -2
6 * 2    -- 12
7 / 2    -- 3.5
-8.1     -- -8.1
+8       -- +8
</eucode>

<p>
<a name=inf_nan></a> Computing a result that is too big (i.e. outside of -1e300
to +1e300) will result in one of the special atoms <b>+infinity</b> or
<b>-infinity</b>.  These appear as inf or -inf when you print them out.  It is
also possible to generate nan or -nan.  "nan" means "not a number", i.e. an
undefined value (such as inf divided by inf). These values are defined in the
IEEE floating-point standard. If you see one of these special values in your
output, it usually indicates an error in your program logic, although
generating inf as an intermediate result may be acceptable in some cases. For
instance, 1/inf is 0, which may be the "right" answer for your algorithm.</p>

<p>
Division by zero, as well as bad arguments to math library routines, e.g.
square root of a negative number, log of a non-positive number etc. cause an
immediate error message and your program is aborted.</p>

<p>
The only reason that you might use unary plus is to emphasize to the reader of
your program that a number is positive. The interpreter does not actually
calculate anything for this.</p>

<h4>Operations on Sequences</h4>

<p>
All of the relational, logical and arithmetic operators described above, as
well as the math routines described in <a href="library.htm">Part II - Library
Routines</a>, can be applied to sequences as well as to single numbers
(atoms).</p>

<p>
When applied to a sequence, a unary (one operand) operator is actually applied
to each element in the sequence to yield a sequence of results of the same
length. If one of these elements is itself a sequence then the same rule is
applied again recursively. e.g.</p>

<eucode>
x = -{1, 2, 3, {4, 5}}   -- x is {-1, -2, -3, {-4, -5}}
</eucode>

<p>
If a binary (two-operand) operator has operands which are both sequences then
the two sequences must be of the same length. The binary operation is then
applied to corresponding elements taken from the two sequences to get a
sequence of results. e.g.</p>

<eucode>
x = {5, 6, 7, 8} + {10, 10, 20, 100}
-- x is {15, 16, 27, 108}
</eucode>

<p>
If a binary operator has one operand which is a sequence while the other is a
single number (atom) then the single number is effectively repeated to form a
sequence of equal length to the sequence operand. The rules for operating on
two sequences then apply. Some examples:</p>

<eucode>
y = {4, 5, 6}
w = 5 * y              -- w is {20, 25, 30}
x = {1, 2, 3}
z = x + y              -- z is {5, 7, 9}
z = x < y              -- z is {1, 1, 1}
w = {{1, 2}, {3, 4}, {5}}
w = w * y              -- w is {{4, 8}, {15, 20}, {30}}
w = {1, 0, 0, 1} and {1, 1, 1, 0}    -- {1, 0, 0, 0}
w = not {1, 5, -2, 0, 0}     -- w is {0, 0, 0, 1, 1}
w = {1, 2, 3} = {1, 2, 4}    -- w is {1, 1, 0}
-- note that the first '=' is assignment, and the
-- second '=' is a relational operator that tests
-- equality 
</eucode>

<p><b>Note:</b> When you wish to compare two strings (or other sequences), you
should <b>not</b> (as in some other languages) use the '=' operator:</p>

<eucode>
if "APPLE" = "ORANGE" then  -- ERROR! 
</eucode>

<p>'=' is treated as an operator, just like '+', '*' etc., so it is applied to
corresponding sequence elements, and the sequences must be the same length.
When they are equal length, the result is a sequence of 1's an 0's. When they
are not equal length, the result is an error. Either way you'll get an error,
since an if-condition must be an atom, not a sequence.  Instead you should use
the equal() built-in routine:</p>

<eucode>
if equal("APPLE", "ORANGE") then  -- CORRECT
</eucode>

<p>In general, you can do relational comparisons using the compare() built-in
routine:</p>

<eucode>
if compare("APPLE", "ORANGE") = 0 then  -- CORRECT
</eucode>

<p>You can use compare() for other comparisons as well:</p>

<eucode>
if compare("APPLE", "ORANGE") < 0 then  -- CORRECT
-- enter here if "APPLE" is less than "ORANGE" (TRUE)
</eucode>

<h4>Subscripting of Sequences</h4>

<p>
A single element of a sequence may be selected by giving the element number in
square brackets. Element numbers start at 1. Non-integer subscripts are rounded
down to an integer.</p>

<p>
For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2. Suppose we
assign something different to x[2]:</p>

<eucode>
x[2] = {11,22,33}
</eucode>

<p>
Then x becomes: {5, {11,22,33}, 9, 0.5, 13}. Now if we ask for x[2] we get
{11,22,33} and if we ask for x[2][3] we get the atom 33. If you try to
subscript with a number that is outside of the range 1 to the number of
elements, you will get a subscript error. For example x[0],  x[-99] or x[6]
will cause errors. So will x[1][3] since x[1] is not a sequence. There is no
limit to the number of subscripts that may follow a variable, but the variable
must contain sequences that are nested deeply enough. The two dimensional
array, common in other languages, can be easily represented with a sequence of
sequences:</p>

<eucode>
x = {
    {5, 6, 7, 8, 9},      -- x[1]
    {1, 2, 3, 4, 5},      -- x[2]
    {0, 1, 0, 1, 0}       -- x[3]
}
</eucode>

<p> where we have written the numbers in a way that makes the structure
 clearer. An expression of the form x[i][j] can be used to access any element.</p>

<p>
The two dimensions are not symmetric however, since an entire "row" can be
selected with x[i], but there is no simple expression to select an entire
column. Other logical structures, such as n-dimensional arrays, arrays of
strings, structures, arrays of structures etc. can also be handled easily and
flexibly:</p>

<p>3-D array:</p>

<eucode>
y = {
    {{1,1}, {3,3}, {5,5}},
    {{0,0}, {0,1}, {9,1}},
    {{-1,9},{1,1}, {2,2}}
}

-- y[2][3][1] is 9
</eucode>

<p>
Array of strings:</p>

<eucode>
s = {"Hello", "World", "Euphoria", "", "Last One"}

-- s[3] is "Euphoria" <br>
-- s[3][1] is 'E'
</eucode>

<p>
A Structure:</p>

<eucode>
employee = {
    {"John","Smith"},
    45000,
    27,
    185.5
}
</eucode>

<blockquote>
To access "fields" or elements within a structure it is good programming style
to make up an enum that names the various fields. This will make your program
easier to read. For the example above you might have:
</blockquote>

<eucode>
enum NAME, FIRST_NAME, LAST_NAME, SALARY, AGE, WEIGHT

employees = {
    {{"John","Smith"}, 45000, 27, 185.5},   -- a[1]
    {{"Bill","Jones"}, 57000, 48, 177.2},   -- a[2]
    -- .... etc.
}

-- employees[2][SALARY] would be 57000.
</eucode>

<p>The length() built-in function will tell you the length of a sequence.  So
the last element of a sequence s, is:</p>

<eucode>
s[length(s)]
</eucode>

<p>A short-hand for this is:</p>

<eucode>
s[$]
</eucode>

<p>Similarly,</p>

<eucode>
s[length(s)-1]
</eucode>

<p>can be simplified to:</p>

<eucode>
s[$-1]
</eucode>

<p>The $ symbol equals the length of the sequence. $ may only appear between
square braces. Where there's nesting, e.g.:</p>

<eucode>
s[$ - t[$-1] + 1]
</eucode>

<p>The first $ above refers to the length of s, while the second $ refers to
the length of t (as you'd probably expect).  An example where $ can save a lot
of typing, make your code clearer, and probably even faster is:</p>

<eucode>
longname[$][$] -- last element of the last element
</eucode>

<p>Compare that with the equivalent:</p>

<eucode>
longname[length(longname)][length(longname[length(longname)])]
</eucode>

<p><b>Subscripting and function side-effects:</b> In an assignment statement,
with left-hand-side subscripts:</p>

<eucode>
lhs_var[lhs_expr1][lhs_expr2]... = rhs_expr
</eucode>

<p>The expressions are evaluated, and any subscripting is performed, from left
to right. It is possible to have function calls in the right-hand-side
expression, or in any of the left-hand-side expressions.  If a function call
has the side-effect of modifying the lhs_var, it is not defined whether those
changes will appear in the final value of the lhs_var, once the assignment has
been completed.  To be sure about what is going to happen, perform the function
call in a separate statement, i.e. do not try to modify the lhs_var in two
different ways in the same statement.  Where there are no left-hand-side
subscripts, you can always assume that the final value of the lhs_var will be
the value of rhs_expr, regardless of any side-effects that may have changed
lhs_var.</p>

<p>
<b>Euphoria data structures are almost infinitely flexible.</b> Arrays in other
languages are constrained to have a fixed number of elements, and those
elements must all be of the same type. Euphoria eliminates both of those
restrictions.  You can easily add a new structure to the employee sequence
above, or store an unusually long name in the NAME field and Euphoria will take
care of it for you. If you wish, you can store a variety of different employee
"structures", with different sizes, all in one sequence.</p>

<p>
Not only can a Euphoria program easily represent all conventional data
structures but you can create very useful, flexible structures that would be
extremely hard to declare in a conventional language.  See <a
href="refman_2.htm#3">Euphoria versus Conventional Languages</a>.</p>

<p>
Note that expressions in general may not be subscripted, just variables. For
example: {5+2,6-1,7*8,8+1}[3] is <i>not</i> supported, nor is something like:
date()[MONTH]. You have to assign the sequence returned by date() to a
variable, then subscript the variable to get the month.</p>

<h4>Slicing of Sequences</h4>

<p>
A sequence of consecutive elements may be selected by giving the starting and
ending element numbers. For example if x is {1, 1, 2, 2, 2, 1, 1, 1} then
x[3..5] is the sequence {2, 2, 2}. x[3..3] is the sequence {2}. x[3..2] is also
allowed. It evaluates to the length-0 sequence {}.  If y has the value:
{"fred", "george", "mary"} then y[1..2] is {"fred", "george"}.</p>

<p>
We can also use slices for overwriting portions of variables. After x[3..5] =
{9, 9, 9} x would be {1, 1, 9, 9, 9, 1, 1, 1}. We could also have said x[3..5]
= 9 with the same effect. Suppose y is {0, "Euphoria", 1, 1}.  Then y[2][1..4]
is "Euph". If we say y[2][1..4]="ABCD" then y will become {0, "ABCDoria", 1,
1}.</p>

<p>
In general, a variable name can be followed by 0 or more subscripts, followed
in turn by 0 or 1 slices. Only variables may be subscripted or sliced, not
expressions.</p>

<p>
We need to be a bit more precise in defining the rules for <strong>empty
slices</strong>. Consider a slice s[i..j] where s is of length n. A slice from
i to j, where  j = i-1  and i >= 1 produces the <a
href="refman_2.htm#empty_seq">empty sequence</a>, even if i = n+1. Thus 1..0
and n+1..n and everything in between are legal <b> (empty) slices</b>.  Empty
slices are quite useful in many algorithms. A slice from i to j where j < i - 1
is illegal , i.e. "reverse" slices such as s[5..3] are not allowed.</p>

<p>
We can also use the $ shorthand with slices, e.g.</p>

<eucode>
s[2..$]
s[5..$-2]
s[$-5..$]
s[$][1..floor($/2)] -- first half of the last element of s
</eucode>

<h4>Concatenation of Sequences and Atoms - The '&' Operator</h4>

<p>
Any two objects may be concatenated using the <strong>&</strong> operator. The
result is a sequence with a length equal to the sum of the lengths of the
concatenated objects (where atoms are considered here to have length 1).
e.g.</p>

<eucode>
{1, 2, 3} & 4              -- {1, 2, 3, 4}

4 & 5                      -- {4, 5}

{{1, 1}, 2, 3} & {4, 5}    -- {{1, 1}, 2, 3, 4, 5}

x = {}
y = {1, 2}
y = y & x                  -- y is still {1, 2}
</eucode>

<p>
You can delete element i of any sequence s by concatenating the parts of the
sequence before and after i:</p>

<eucode>
s = s[1..i-1] & s[i+1..length(s)]
</eucode>

<p>This works even when i is 1 or length(s), since s[1..0] is a legal empty
slice, and so is s[length(s)+1..length(s)].</p>

<h4>Sequence-Formation</h4>

<p>
Finally, sequence-formation, using braces and commas:</p>

<eucode>
{a, b, c, ... }
</eucode>

<p>
is also an operator. It takes n operands, where n is 0 or more, and makes an
n-element sequence from their values. e.g.</p>

<eucode>
x = {apple, orange*2, {1,2,3}, 99/4+foobar}
</eucode>

<p>
The sequence-formation operator is listed at the bottom of the <a
href="refman_2.htm#2A">precedence chart</a>.</p>

<h4>Other Operations on Sequences</h4>

<p>
Some other important operations that you can perform on sequences have English
names, rather than special characters. These operations are built-in to
<strong>ex.exe</strong>/<strong>exw.exe</strong>/<strong>exu</strong>, so
they'll always be there, and so they'll be fast. They are described in detail
in <a href="library.htm">Part II - Library Routines</a>, but are important
enough to Euphoria programming that we should mention them here before
proceeding. You call these operations as if they were subroutines, although
they are actually implemented much more efficiently than that.</p>


<h5>length(object o)</h5>

<p>Returns the length of a sequence s1.</p>

<p>This is the number of elements in s1. Some of these elements may be
sequences that contain elements of their own, but length just gives you the
"top-level" count. You'll get an error if you ask for the length of an atom.
e.g.</p>

<eucode>
length({5,6,7})             -- 3
length({1, {5,5,5}, 2, 3})  -- 4 (not 6!)
length({})                  -- 0
length(5)                   -- error!
</eucode>

<h5>repeat(object o1, integer times)</h5>

<p>Returns a sequence that consists of an item repeated count times.
e.g.</p>

<eucode>
repeat(0, 100)         -- {0,0,0,...,0}   i.e. 100 zeros
repeat("Hello", 3)     -- {"Hello", "Hello", "Hello"}
repeat(99,0)           -- {}
</eucode>

<p>The item to be repeated can be any atom or sequence.</p>

<h5>append(sequence s1, object o1)</h5>

<p>Returns a sequence by adding an object o1 to the end of a sequence
s1.</p>

<eucode>
append({1,2,3}, 4)         -- {1,2,3,4}
append({1,2,3}, {5,5,5})   -- {1,2,3,{5,5,5}}
append({}, 9)              -- {9}
</eucode>

<p>The length of the new sequence is always 1 greater than the length of
the original sequence. The item to be added to the sequence can be any atom or
sequence.</p>

<h5>prepend(sequence s1, object o1)</h5>

<p>Returns a new sequence by adding an element to the beginning of a
sequence s. e.g.</p>

<eucode>
append({1,2,3}, 4)         -- {1,2,3,4}
prepend({1,2,3}, 4)        -- {4,1,2,3}

append({1,2,3}, {5,5,5})   -- {1,2,3,{5,5,5}}
prepend({}, 9)             -- {9}
append({}, 9)              -- {9}
</eucode>

<p>The length of the new sequence is always 1 greater than the length of
the original sequence. The item to be added to the sequence can be any atom or
sequence.</p>

<p>
These two built-in functions, <strong>append(</strong>) and
<strong>prepend()</strong>, have some similarities to the concatenate operator,
<strong>&</strong>, but there are clear differences. e.g.</p>

<eucode>
-- appending a sequence is different
append({1,2,3}, {5,5,5})   -- {1,2,3,{5,5,5}}
{1,2,3} & {5,5,5}          -- {1,2,3,5,5,5}

-- appending an atom is the same
append({1,2,3}, 5)         -- {1,2,3,5}
{1,2,3} & 5                -- {1,2,3,5}
</eucode>

<h3>Precedence Chart</h3>

<p>
The precedence of operators in expressions is as follows:</p>

<p><strong>highest precedence</strong></p>

<pre>
function/type calls
unary-  unary+  not
*  /
+  -
&
<  >  <=  >=  =  !=
and  or  xor
</pre>

<p><strong>lowest precedence</strong></p>
<pre>
{ , , , }
</pre>

<p>
Thus 2+6*3 means 2+(6*3) rather than (2+6)*3. Operators on the same line
above have equal precedence and are evaluated left to right. You can force
any order of operations by placing round brackets ( ) 
around an expression.</p>

<p>
The equals symbol '=' used in an <a href="refman_2.htm#assign">assignment
statement</a> is not an operator, it's just part of the syntax of the
language.</p>

<h2>Euphoria versus Conventional Languages</h2>

<p>
By basing Euphoria on this one, simple, general, recursive data structure, a
tremendous amount of the complexity normally found in programming languages has
been avoided. The arrays, structures, unions, arrays of records,
multidimensional arrays, etc. of other languages can all be easily represented
in Euphoria with sequences. So can higher-level structures such as lists,
stacks, queues, trees etc.</p>

<p>
Furthermore, in Euphoria you can have sequences of mixed type; you can assign
any object to an element of a sequence; and sequences easily grow or shrink in
length without your having to worry about storage allocation issues.  The exact
layout of a data structure does not have to be declared in advance, and can
change dynamically as required. It is easy to write generic code, where, for
instance, you push or pop a mix of various kinds of data objects using a single
stack. Making a flexible list that contains a variety of different kinds of
data objects is trivial in Euphoria, but requires dozens of lines of ugly code
in other languages.</p>

<p>
Data structure manipulations are very efficient since the Euphoria interpreter
will point to large data objects rather than copy them.</p>

<p>
Programming in Euphoria is based entirely on creating and manipulating
flexible, dynamic sequences of data. Sequences are <i>it</i> - there are no
other data structures to learn.  You operate in a simple, safe, elastic world
of <i>values</i>, that is far removed from the rigid, tedious, dangerous world
of bits, bytes, pointers and machine crashes.</p>

<p>
Unlike other languages such as LISP and Smalltalk, Euphoria's "garbage
collection" of unused storage is a continuous process that never causes random
delays in execution of a program, and does not pre-allocate huge regions of
memory.</p>

<p>
The language definitions of conventional languages such as C, C++, Ada, etc.
are very complex. Most programmers become fluent in only a subset of the
language. The ANSI standards for these languages read like complex legal
documents.</p>

<p>
You are forced to write different code for different data types simply to copy
the data, ask for its current length, concatenate it, compare it etc. The
manuals for those languages are packed with routines such as "strcpy",
"strncpy", "memcpy", "strcat",  "strlen", "strcmp", "memcmp", etc. that each
only work on one of the many types of data.</p>

<p>
Much of the complexity surrounds issues of data type. How do you define new
types? Which types of data can be mixed? How do you convert one type into
another in a way that will keep the compiler happy? When you need to do
something requiring flexibility at run-time, you frequently find yourself
trying to fake out the compiler.</p>

<p>
In these languages the numeric value 4 (for example) can have a different
meaning depending on whether it is an int, a char, a short, a double, an int *
etc. In Euphoria, 4 is the atom 4, period. Euphoria has something called types
as we shall see later, but it is a much simpler concept.</p>

<p>
Issues of dynamic storage allocation and deallocation consume a great deal of
programmer coding time and debugging time in these other languages, and make
the resulting programs much harder to understand. Programs that must run
continuously often exhibit storage "leaks", since it takes a great deal of
discipline to safely and properly free all blocks of storage once they are no
longer needed.</p>

<p>
Pointer variables are extensively used. The pointer has been called the "go to"
of data structures. It forces programmers to think of data as being bound to a
fixed memory location where it can be manipulated in all sorts of low-level,
non-portable, tricky ways. A picture of the actual hardware that your program
will run on is never far from your mind. Euphoria does not have pointers and
does not need them.</p>

<h2>Declarations</h2>

<h3>Identifiers</h3>

<p>
<strong>Identifiers</strong>, which consist of variable names and other
user-defined symbols, may be of any length. Upper and lower case are distinct.
Identifiers must start with a letter and then be followed by letters, digits or
underscores. The following <strong>reserved words</strong> have special meaning
in Euphoria and may not be used as identifiers:</p>
                                   
<eucode>
and            elsif        function      not           type
break          elsifdef     global        or            until          
by             end          if            procedure     while        
constant       entry        ifdef         retry         with
continue       enum         include       return        without
do             exit         label         then          xor
else           for          loop          to
</eucode>

<p>The Euphoria editor displays these words in blue.</p>

<p>Identifiers can be used in naming the following:</p>

<ul>
<li>procedures</li>
<li>functions</li>
<li>types</li>
<li>variables</li>
<li>constants</li>
</ul>

<h4>procedures</h4>

<p>These perform some computation and may have a list of parameters, e.g.</p>

<eucode>
procedure empty()
end procedure

procedure plot(integer x, integer y)
    position(x, y)
    puts(1, '*')
end procedure
</eucode>

<p>
There are a fixed number of named parameters, but this is not restrictive since
any parameter could be a variable-length sequence of arbitrary objects. In many
languages variable-length parameter lists are impossible.  In C, you must set
up strange mechanisms that are complex enough that the average programmer
cannot do it without consulting a manual or a local guru.</p>

<p>
A copy of the value of each argument is passed in. The formal parameter
variables may be modified inside the procedure but this does not affect the
value of the arguments.</p>

<dl>
<dt><b>Performance Note:</b></dt>
<dd>
The interpreter does not actually copy sequences or floating-point numbers
unless it becomes necessary. For example,

<eucode>
y = {1,2,3,4,5,6,7,8.5,"ABC"}
x = y
</eucode>

<p>
The statement x = y does not actually cause a new copy of y to be created. Both x and y will 
simply "point" to the same sequence. If we later perform x[3] = 9, then a separate sequence 
will be created for x in memory (although there will still be just one shared copy of 8.5 and
"ABC"). The same thing applies to "copies" of arguments passed in to subroutines.</p></dd>

</dl>
<p>
For a number of procedures or functions - see below -, some parameters may have the same value
in many cases. The most expected value for any parameter may be given a default value. Omitting the value of such a parameter on a given call will cause its default value to be passed.</p>
<eucode>
procedure foo(sequence s,integer n=1)
?n+length(s)
end procedure

foo("abc") -- prints out 4 = 3+1. n was not specified, so was set to 1.
foo("abc",3) -- prints out 6 = 3+3
</eucode>
<p>
This is not limited to the last parameter(s):</p>
<eucode>
procedure bar(sequence s="abc",integer n,integer p=1)
?length(s)+n+p
end procedure
bar(,2) -- prints out 6 = 3 + 2 + 1
bar(2)  -- errors out, as 2 is not a sequence
bar(,2,) -- same as bar(,2)
bar(,2,3) -- prints out 8 = 3 + 22 + 3
bar({},2,) -- prints out 3 = 0 + 2 + 1
bar()      -- errors out, second parameter is omitted, but doesn't have a defailt value
</eucode>
<p>
Any expression may be used in a default value. Parameters that have been already mentioned may even be part of the expression:</p>
<eucode>
procedure baz(sequence s,integer n=length(s))
?n
end procedure
baz("abcd") -- prints out 4
</eucode>

<h4>functions</h4>

<p>
These are just like procedures, but they return a value, and can be used in an
expression, e.g.</p>

<eucode>
function max(atom a, atom b)
    if a >= b then
        return a
    else
        return b
    end if
end function
</eucode>

<p>
Any Euphoria object can be returned.  You can, in effect, have multiple return
values, by returning a sequence of objects. e.g.</p>

<eucode>
return {x_pos, y_pos}
</eucode>

<p>
We will use the general term "subroutine", or simply "routine" when a remark is
applicable to both procedures and functions.</p>
<p>
Defaulted parameters can be used in functions exactly as they are in procedures. See the section above for a few examples.</p>

<a name="types"></a>
<h4>types</h4>

<p>
These are special functions that may be used in declaring the allowed values
for a variable. A type must have exactly one parameter and should return an
atom that is either true (non-zero) or false (zero).  Types can also be called
just like other functions. See <a href="refman_2.htm#43">2.4.3 Specifying the
Type of a Variable</a>.</p>
<p>
Although there are no restrictions to using defaulted parameters with types, their use is so much constrained by a type having excatly one argument that they are of little practical help there.</p>

<a name="variables"></a>
<h4>variables</h4>

<p>These may be assigned values during execution e.g.</p>

<eucode>
-- x may only be assigned integer values
integer x
x = 25

-- a, b and c may be assigned *any* value
object a, b, c
a = {}
b = a
c = 0
</eucode>

<p>
When you declare a variable you name the variable (which protects you against
making spelling mistakes later on) and you specify the values that may legally
be assigned to the variable during execution of your program.</p>
<p>
The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as "variable xyz has never been assigned a value".</p>
<p>
To guard against forgetting to initialise a variable, and also because it may make the code clearer to read, you can combine declaration and assignment:</p>
<eucode>
integer n = 5
</eucode>
This is equivalent to
<eucode>
integer n
n = 5
</eucode>
<p>
It is not unfrequent that one defines a private variable that bears the same name as one already in scope. You can reuse the value of that variable when performing an initialisation on declare:</p>
<eucode>
integer n
n=5
procedure foo()
integer n = n + 2
?n
end procedure
foo() -- prints out 7
</eucode>

<a name="constants"></a>
<h4>constants</h4>

<p>
These are variables that are assigned an initial value that can never change
e.g.</p>

<eucode>
constant MAX = 100
constant Upper = MAX - 10, Lower = 5
constant name_list = {"Fred", "George", "Larry"}
</eucode>

<p>
The result of any expression can be assigned to a constant, even one involving
calls to previously defined functions, but once the assignment is made, the
value of the constant variable is "locked in".</p>

<p>
Constants may not be declared inside a subroutine.</p>

<a name="enum"></a>
<h5>enum</h5>

<p>
An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1.</p>

<eucode>
enum ONE, TWO, THREE, FOUR

-- ONE is 1, TWO is 2, THREE is 3, FOUR is 4
</eucode>

<p>
You can change the value of any one item by assigning it a numeric value. Enums
can only take numeric values. You cannot set the starting value to an
expression or other variable. Subsequent values are always the previous value
plus one, unless they too are assigned a default value.</p>

<eucode>
enum ONE, TWO, THREE, ABC=10, DEF, XYZ

-- ONE is 1, TWO is TWO, THREE is 3
-- ABC is 10, DEF is 11, XYZ is 12.
</eucode>

<a name="scope"></a>
<h3>Scope</h3>

<p> 
A symbol's <i>scope</i> is the portion of the program where that symbol's
declaration is in effect, i.e. where that symbol is <i>visible</i>. </p>

<p>
Euphoria has many pre-defined procedures, functions and types.  These are
defined automatically at the start of any program.  The Euphoria editor shows
them in magenta. These pre-defined names are not reserved. You can override
them with your own variables or routines.</p>

<p>
Every user-defined symbol must be declared before it is used.  You can read a
Euphoria program from beginning to end without encountering any user-defined
variables or routines that haven't been defined yet. It is possible to call a
routine that comes later in the source, but you must use the special functions,
<strong>routine_id()</strong>, and either <strong>call_func()</strong> or
<strong>call_proc()</strong> to do it.  See <a href="library.htm#dyn_call">Part
II - Library Routines - Dynamic Calls</a>.</p>

<p>
Procedures, functions and types can call themselves <i>recursively</i>. Mutual
recursion, where routine A calls routine B which directly or indirectly calls
routine A, requires the <a class="brown" href="lib_dyn.htm#routine_id">
<b>routine_id()</b></a> mechanism.</p>

<p>
<a name=scope></a> A symbol is defined from the point where it is declared to
the end of its scope.  The scope of a variable declared inside a procedure or
function (a private variable) ends at the end of the procedure or function.
The scope of all other variables, constants, procedures, functions and types
ends at the end of the source file in which they are declared and they are
referred to as local, unless the keyword global precedes their declaration, in
which case their scope extends indefinitely.</p>

<p>
When you <b>include</b> a Euphoria file in a main file (see <a
href="refman_2.htm#6">2.6 Special Top-Level Statements</a>), only the variables
and routines declared using the global or export  keywords are accessible or
even visible to the main file. The other, non-global, non-exported declarations
in the included file are forgotten at the end of the included file, and you
will get an error message, "not declared", if you try to use them in the main
file.</p>

<p>
Symbols marked as global can be used externally. All other symbols can only be
used internally within their own file. This information is helpful when
maintaining or enhancing the file, or when learning how to use the file. You
can make changes to the internal routines and variables, without having to
examine other files, or notify other users of the include file.</p>
 
<p>Symbols marked as export are similar to global symbols, except that they
are only visible to files that directly include their file, or directly include
a file that includes the file through the export include statement. </p>
 
<p>Sometimes, when using include files developed by others, you will encounter
a naming conflict.  One of the include file authors has used the same name for
a global symbol as one of the other authors. If you have the source, you can
simply edit one of the include files to correct the problem, but then you'd
have repeat this process whenever a new version of the include file was
released. Euphoria has a simpler way to solve this. Using an extension to the
include statement, you can say for example:</p>

<eucode>
include johns_file.e as john
include bills_file.e as bill

john:x += 1
bill:x += 2
</eucode>

<p>In this case, the variable x was declared in two different files, and you
want to refer to both variables in your file.  Using the <i>namespace
identifier</i> of either john or bill, you can attach a prefix to x to indicate
which x you are referring to.  We sometimes say that john refers to one
<i>namespace</i>, while bill refers to another distinct <i>namespace</i>.  You
can attach a namespace identifier to any user-defined variable, constant,
procedure or function. You can do it to solve a conflict, or simply to make
things clearer. A namespace identifier has local scope. It is known only within
the file that declares it, i.e. the file that contains the include statement.
Different files might define different namespace identifiers to refer to the
same included file.</p>

<p>
There is a special, reserved namespace, "eu" for referring to built-in euphoria
routines.  This can be useful when a built-in routine has been overridden: </p>

<eucode>
procedure puts( integer fn, object text )
    eu:puts(fn, "Overloaded puts says: "& text )
end procedure

puts(1, "Hello, world!\n")
eu:puts(1, "Hello, world!\n")
</eucode>

<p>
Files can also declare a default namespace to be used with the file.  When a
file with a default namespace is included, if the include statement did not
specify a namespace, then the default namespace will be automatically declared
in that file.  If the include statement declares a namespace for the newly
included file, then the specified namespace will be available instead of the
default.  No two files can use the same namespace identifier.  If two files
with the same default namespaces are included, at least one will be required to
have a different namespace to be specified.  </p>

<p>
To declare a default namespace in a file, the first token (whitespace and
comments are ignored) should be 'namespace' followed by the desired name: </p>

<eucode>
-- foo.e :  this file does some stuff
namespace foo
</eucode>

<p>
Euphoria encourages you to restrict the scope of symbols. If all symbols were
automatically global to the whole program, you might have a lot of naming
conflicts, especially in a large program consisting of files written by many
different programmers. A naming conflict might cause a compiler error message,
or it could lead to a very subtle bug, where different parts of a program
accidentally modify the same variable without being aware of it.  Try to use
the most restrictive scope that you can. Make variables
<strong>private</strong> to one routine where possible, and where that isn't
possible, make them <strong>local</strong> to a file, rather than
<strong>global</strong> to the whole program.</p>

<p>
When Euphoria looks up the declaration of a symbol, it first checks the current
routine, then the current file, then globals in other files. Symbols that are
more local will <i>override</i> symbols that are more global.  At the end of
the scope of the local symbol, the more global symbol will be visible again.
If multiple global symbols are found, Euphoria will look to see if there is
only one matching symbol that resides in a file that was directly or indirectly
included from the file which is attempting to use the symbol.  This way, third
party libraries can be used in the same application, even if they have
conflicting symbols.  The application code that uses the libraries will have to
use explicit namespaces to deconflict the symbols, but the libraries themselves
will not need to be edited.</p>

<p>
Using a namespace identifier with a symbol name causes Euphoria to resolve the
symbol as though it were being used from the file associated with the
namespace.  This means that a namespace could be associated with the main
include file of a multi-file library, and using the namespace associated with
the main file will allow deconfliction of all symbols within the library from
other symbols in files independent of the library.  Of course, if there are
conflicting symbols within the library that require the use of namespace
identifiers from within the library itself, users of the library will not be
able to deconflict those symbols with the namespace associated with the main
file of the library.</p>

<p>
<strong>Constant</strong> declarations must be outside of any subroutine.
Constants can be global or local, but not <strong>private</strong>.</p>

<p>
Variable declarations inside a subroutine must all appear at the beginning,
before the executable statements of the subroutine.</p>

<p>
Declarations at the top level, outside of any subroutine, must not be nested
inside a loop or <a href="refman_2.htm#if">if-statement</a>.</p>

<p>
<a name=loop_scope></a> The controlling variable used in a <a
href="refman_2.htm#for">for-loop</a> is special. It is automatically declared
at the beginning of the loop, and its scope ends at the end of the for-loop. If
the loop is inside a function or procedure, the loop variable is a
<strong>private</strong> variable and may not have the same name as any other
<strong>privat</strong>e variable. When the loop is at the top level, outside
of any function or procedure, the loop variable is a <strong>loca</strong>l
variable and may not have the same name as any other <strong>local</strong>
variable in that file. You can use the same name in many different for-loops as
long as the loops aren't nested. You do not declare loop variables as you would
other variables. The range of values specified in the for statement defines the
legal values of the loop variable - specifying a type would be redundant and is
not allowed.</p>

<h3>Specifying the Type of a Variable</h3>

<p>
So far you've already seen some examples of variable types but now we will
define types more precisely.</p>

<p>
Variable declarations have a type name followed by a list of the variables
being declared. For example,</p>

<eucode>
object a

global integer x, y, z

procedure fred(sequence q, sequence r)
</eucode>

<p>
The types: <strong>object</strong>, <strong>sequence</strong>, <b>atom</b> and
<strong>integer</strong> are <strong>predefined</strong>.  Variables of type
<strong>object</strong> may take on <i>any</i> value.  Those declared with type
<strong>sequenc</strong>e must always be sequences.  Those declared with type
<strong>atom</strong> must always be atoms.</p>

<p>
<a name="integer"></a>
Those declared with type <strong>integer</strong> must be atoms with integer
values from -1073741824 to +1073741823 inclusive. You can perform exact
calculations on larger integer values, up to about 15 decimal digits, but
declare them as <strong>atom</strong>, rather than integer.</p>

<dl>
<dt>
<b>Note:</b></dt>

<dd>
<p>
In a procedure or function parameter list like the one for fred() above, a type
name may only be followed by a single parameter name.</p>
</dd>

<dt><b>Performance Note:</b></dt>

<dd>
<p>
Calculations using variables declared as integer will usually be somewhat
faster than calculations involving variables declared as atom. If your machine
has floating-point hardware, Euphoria will use it to manipulate atoms that
aren't representable as integers. If your machine doesn't have floating-point
hardware, Euphoria will call software floating-point arithmetic routines
contained in <strong>ex.exe</strong> (or in Windows).  You can force ex.exe to
bypass any floating-point hardware, by setting an environment variable:

<console>
SET NO87=1
</console>

The slower software routines will be used, but this could be of some advantage
if you are worried about the floating-point bug in some early Pentium
chips.</p></dd>
</dl>

<p>
<a name=type></a> To augment the <a href="refman_2.htm#43">predefined
types</a>, you can create <strong>user-defined types</strong>. All you have to
do is define a single-parameter function, but declare it with <strong>type ...
end type</strong> instead of <strong>function ... end function</strong>.  For
example,</p>

<eucode>
type hour(integer x)
    return x >= 0 and x <= 23
end type

hour h1, h2

h1 = 10      -- ok
h2 = 25      -- error! program aborts with a message
</eucode>

<p>
Variables h1 and h2 can only be assigned integer values in the range 0 to 23
inclusive. After each assignment to h1 or h2 the interpreter will call hour(),
passing the new value.  The value will first be checked to see if it is an
integer (because of "integer x"). If it is, the return statement will be
executed to test the value of x (i.e. the new value of h1 or h2).  If hour()
returns true, execution continues normally. If hour() returns false then the
program is aborted with a suitable diagnostic message.</p>

<p>
"hour" can be used to declare subroutine parameters as well:</p>

<eucode>
procedure set_time(hour h)
</eucode>

<p>
set_time() can only be called with a reasonable value for parameter h,
otherwise the program will abort with a message.</p>

<p>
A variable's type will be checked after each assignment to the variable (except
where the compiler can predetermine that a check will not be necessary), and
the program will terminate immediately if the type function returns false.
Subroutine parameter types are checked each time that the subroutine is called.
This checking guarantees that a variable can never have a value that does not
belong to the type of that variable.</p>

<p>
<a name=typechk></a> Unlike other languages, the type of a variable does not
affect any calculations on the variable. Only the value of the variable matters
in an expression. The type just serves as an error check to prevent any
"corruption" of the variable.  </p> <p> User-defined types can catch unexpected
logical errors in your program.  They are not designed to catch or correct user
input errors.</p>

<p>
Type checking can be turned off or on between subroutines using the with
type_check or without type_check <a href="refman_2.htm#62">special
statements</a>.  It is initially on by default.</p>

 
<dl>
<dt>
<b>Note to Benchmarkers:</b></dt>
<dd>
<p>
When comparing the speed of Euphoria programs against programs written in other
languages, you should specify <strong>without type_check</strong> at the top of
the file.  This gives Euphoria permission to skip run-time type checks, thereby
saving some execution time. All other checks are still performed, e.g.
subscript checking, uninitialized variable checking etc.  Even when you turn
off type checking, Euphoria reserves the right to make checks at strategic
places, since this can actually allow it to run your program <i>faster</i> in
many cases.  So you may still get a type check failure even when you have
turned off type checking. Whether type checking is on or off, you will never
get a <b><i>machine-level</i></b> exception.  <strong>You will always get a
meaningful message from Euphoria when something goes wrong</strong>.  (<i>This
might not be the case when you <a href="lib_mach.htm#poke">poke</a> directly
into memory, or call routines written in C or machine code.</i>)</p></dd>
</dl>

<p>
Euphoria's method of defining types is simpler than what you will find in other
languages, yet Euphoria provides the programmer with <i>greater</i> flexibility
in defining the legal values for a type of data. Any algorithm can be used to
include or exclude values. You can even declare a variable to be of type object
which will allow it to take on <i>any</i> value. Routines can be written to
work with very specific types, or very general types.</p>

<p>
For many programs, there is little advantage in defining new types, and you may
wish to stick with the four <a href="refman_2.htm#43">predefined types</a>.
Unlike other languages, Euphoria's type mechanism is optional.  You don't need
it to create a program. </p>

<p>
However, for larger programs, strict type definitions can aid the process of
debugging.  Logic errors are caught close to their source and are not allowed
to propagate in subtle ways through the rest of the program.  Furthermore, it
is easier to reason about the misbehavior of a section of code when you are
guaranteed that the variables involved always had a legal value, if not the
desired value.</p>

<p>
Types also provide meaningful, machine-checkable documentation about your
program, making it easier for you or others to understand your code at a later
date. Combined with the <a href="refman_2.htm#21">subscript checking</a>,
uninitialized variable checking, and other checking that is always present,
strict run-time type checking makes debugging much easier in Euphoria than in
most other languages. It also increases the reliability of the final program
since many latent bugs that would have survived the testing phase in other
languages will have been caught by Euphoria.</p>

<dl>
<dt>
<b>Anecdote 1:</b></dt>
<dd>
<p>
In porting a large C program to Euphoria, a number of latent bugs were
discovered. Although this C program was believed to be totally "correct", we
found: a situation where an uninitialized variable was being read; a place
where element number "-1" of an array was routinely written and read; and a
situation where something was written just off the screen. These problems
resulted in errors that weren't easily visible to a casual observer, so they
had survived testing of the C code.</p></dd>

<dt>
<b>Anecdote 2:</b></dt>
<dd>
<p>
The Quick Sort algorithm presented on page 117 of <i>Writing Efficient
Programs</i> by Jon Bentley has a subscript error! The algorithm will sometimes
read the element just <i>before</i> the beginning of the array to be sorted,
and will sometimes read the element just <i>after</i> the end of the array.
Whatever garbage is read, the algorithm will still work - this is probably why
the bug was never caught. But what if there isn't any (virtual) memory just
before or just after the array? Bentley later modifies the algorithm such that
this bug goes away -- but he presented this version as being correct.
<b><i>Even the experts need subscript checking!</i></b></p></dd>

<dt>
<b>Performance Note:</b></dt>

<dd>
<p>
When typical user-defined types are used extensively, type checking adds only
20 to 40 percent to execution time. Leave it on unless you really need the
extra speed. You might also consider turning it off for just a few
heavily-executed routines.  <a href="refman_3.htm#2">Profiling</a> can help
with this decision.</p></dd>

</dl>

<h2>Statements</h2>

<p>

 The following kinds of executable statements are available:</p>
<ul>
<li><a href="refman_2.htm#assign">assignment statement</a></li>
<li><a href="refman_2.htm#proc">procedure call</a></li>
<li><a href="refman_2.htm#if">if statement</a></li>
<li><a href="refman_2.htm#while">while statement</a></li>
<li><a href="refman_2.htm#while">loop ... until statement</a></li>
<li><a href="refman_2.htm#for">for statement</a></li>
<li><a href="refman_2.htm#return">return statement</a></li>
<li><a href="refman_2.htm#exit">exit statement</a></li>
<li><a href="refman_2.htm#break">break statement</a></li>
<li><a href="refman_2.htm#continue">continue statement</a></li>
<li><a href="refman_2.htm#retry">retry statement</a></li>
<li><a href="refman_2.htm#switch">switch statement</a></li>
<li><a href="#ifdef">ifdef statement</a></li>
</ul>

<p>
Semicolons are not used in Euphoria, but you are free to put as many statements
as you like on one line, or to split a single statement across many lines. You
may not split a statement in the middle of an identifier, string, number or
keyword.</p>

<h3>Assignment Statement</h3>

<p>
An <strong>assignment statement</strong> assigns the value of an expression to
a simple variable, or to a subscript or slice of a variable. e.g.</p>

<eucode>
x = a + b
y[i] = y[i] + 1
y[i..j] = {1, 2, 3}
</eucode>

<p>
The previous value of the variable, or element(s) of the subscripted or sliced
variable are discarded.  For example, suppose x was a 1000-element sequence
that we had initialized with:</p>

<eucode>
object x

x = repeat(0, 1000)  -- a sequence of 1000 zeros
</eucode>

<p>and then later we assigned an atom to x with:</p>

<eucode>
x = 7
</eucode>

<p>
This is perfectly legal since x is declared as an <strong>object</strong>. The
previous value of x, namely the 1000-element sequence, would simply disappear.
Actually, the space consumed by the 1000-element sequence will be automatically
recycled due to Euphoria's dynamic storage allocation.</p>

<p>
Note that the equals symbol '=' is used for both assignment and for <a
href="refman_2.htm#23">equality testing</a>.  There is never any confusion
because an assignment in Euphoria is a statement only, it can't be used as an
expression (as in C).</p>

<h4>Assignment with Operator</h4>

<p>
Euphoria also provides some additional forms of the assignment statement.</p>

<p>
To save typing, and to make your code a bit neater, you can combine assignment
with one of the operators:</p>
 
<eucode>+ - / * &</eucode>

<p>For example, instead of saying:</p>

<eucode>
mylongvarname = mylongvarname + 1
</eucode>

<p>You can say:</p>

<eucode>
mylongvarname += 1
</eucode>

<p>Instead of saying:</p>

<eucode>
galaxy[q_row][q_col][q_size] = galaxy[q_row][q_col][q_size] * 10
</eucode>

<p>You can say:</p>

<eucode>
galaxy[q_row][q_col][q_size] *= 10
</eucode>

<p>and instead of saying:</p>

<eucode>
accounts[start..finish] = accounts[start..finish] / 10
</eucode>

<p>You can say:</p>

<eucode>
accounts[start..finish] /= 10
</eucode>

<p>
In general, whenever you have an assignment of the form:</p>
<console>
<b><i>left-hand-side = left-hand-side op expression</i></b>
</console>

<p>You can say:</p>

<console>
<b><i>left-hand-side op= expression</i></b>
</console>

<p>where <b><i>op</i></b> is one of:</p>

<eucode>+ - * / &</eucode>

<p>
When the left-hand-side contains multiple subscripts/slices, the <i>op=</i>
form will usually execute faster than the longer form. When you get used to it,
you may find the <i>op=</i> form to be slightly more readable than the long
form, since you don't have to visually compare the left-hand-side against the
copy of itself on the right side.</p>

<h4>procedure call</h4>

<p>
A <strong>procedure call</strong> starts execution of a procedure, passing it
an optional list of argument values. e.g.</p>

<eucode>
plot(x, 23)
</eucode>

<h4>return statement</h4>

<p>
A <strong>return statement</strong> returns immediately from a subroutine. If
the subroutine is a function or type then a value must also be returned.
e.g.</p>

<eucode>
return

return {50, "FRED", {}}
</eucode>

<h4>if statement</h4>

<p>
An <strong>if statement</strong> tests a condition to see if it is 0 (false) or
non-zero (true) and then executes the appropriate series of statements. There
may be optional <strong>elsif</strong> and <strong>else</strong> clauses.
e.g.</p>

<eucode>
if a < b then
    x = 1
end if

if a = 9 and find(0, s) then
    x = 4
    y = 5
else
    z = 8
end if

if char = 'a' then
    x = 1
elsif char = 'b' or char = 'B' then
    x = 2
elsif char = 'c' then
    x = 3
else
    x = -1
end if
</eucode>

<p>
Notice that elsif is a contraction of else if, but it's cleaner because it
doesn't require an end if to go with it. There is just one end if for the
entire <strong>if</strong> statement, even when there are many <b>elsif's</b>
contained in it.</p>

<p>
The <strong>if</strong> and <strong>elsif</strong> conditions are tested using
<a href="refman_2.htm#shortcir">short-circuit evaluation</a>. </p>

<p>
<strong>If</strong> statement headers can have a <strong>label</strong> clause
right before the <strong>the</strong>n closing keyword. See the section on <a
href="refman_2.htm#labhdr">labelled block headers </a>. This feature does not
apply to <strong>elsif</strong> conditional statements, as they are not
standalone, just optionally sectioning an if block.</p>

<h4>Iterative code blocks, aka loops.</h4>

<p>
An iterative code block repeats its own execution zero, one or more times.
There are several ways to specify for how long the process should go on, and
how to stop or otherwise alter it.  An iterative block may be informally called
a loop, and each execution of code in a loop is called an iteration of the
loop.</p>

<p>
Euphoria has three flavours of loops. They all may harbor a <a
href="refman_2.htm#labhdr"> labelled block header</a>, in order to make exiting
them more flexible.  </p>

<h5>while statement</h5>

<p>
A <strong>while statement</strong> tests a condition to see if it is non-zero
(true), and while it is true a loop is executed. e.g.</p>

<eucode>
while x > 0 do
    a = a * 2
    x = x - 1
end while
</eucode>

<h5>The loop ... until statement.</h5>

<p>
A <strong>loop ... until statement</strong> tests a condition to see if it is
non-zero (true), and until it is true a loop is executed. e.g.</p>

<eucode>
loop do
    a = a * 2
    x = x - 1
until x<=0
</eucode>

<p>This differs from a <strong>while</strong> loop in more than one way:</p>

<ul>
<li>
The body of the loop is executed at least once, since testing takes place AFTER
it completes.  In a <strong>while</strong>, the test is taken BEFORE execution.
</li>

<li>
The header contains only optional <strong>label</strong> and <strong>while entry</strong> 
tags.
</li>

<li>
The footer of the block, instead of being "end loop", has a distinctive form and holds the 
termination test.
</li>
</ul>

<h5>for statement</h5>

<p>
A <strong>for statement</strong> sets up a special loop with a controlling
<strong>loop variabl</strong>e that runs from an initial value up or down to
some final value. e.g.</p>

<eucode>
for i = 1 to 10 do
    ? i   -- ? is a short form for print()
end for

-- fractional numbers allowed too
for i = 10.0 to 20.5 by 0.3 do
    for j = 20 to 10 by -2 do    -- counting down
        ? {i, j}
    end for
end for
</eucode>

<p>
The <strong>loop variable</strong> is declared automatically and exists until
the end of the loop. Outside of the loop the variable has no value and is not
even declared.  If you need its final value, copy it into another variable
before leaving the loop. The compiler will not allow any assignments to a loop
variable. The initial value, loop limit and increment must all be atoms. If no
increment is specified then +1 is assumed. The limit and increment values are
established when the loop is entered, and are not affected by anything that
happens during the execution of the loop. See also the <a
href="refman_2.htm#loop_scope">scope of the loop variable in 2.4.2
Scope</a>.</p>

<a name="labelhdr"></a>
<h4>Flow control statements.</h4>

<p>
Blocks are good ways toorganise code in easily identifiable chunks. However,
for efficiency, it is often desirable to exi them early or slightly alter their
default course of execution.  </p>

<p>
Exiting a single block of code is done with a single keyword, like
<strong>exit</strong>. Likwise, kipping the rest of an iteration in a single
code block is done using a single keyword, like <strong>continue</strong>. But
sometimes you need to act on a block above the current one, like exiting three
levels of loop, or restarting the iteration of the third loop above. How to do
that?</p>

<p>
By using an optional parameter right after the control flow keyword. The
parameter may take the following form: </p> <ul> <li> A label string, like in
<eucode>break "this_block"</eucode></li> <li> A positive constant integer, the
number of levels to act upon, like in "exit 2" to exit the loop right above the
current one</li> <li> A nonpositive integer, which counts he levels backwards,
like in "continue -1" to start the next iteration of the second topmost loop
(compare with s[$-1])</li> <li> A for loop index variable name, like in "retry
i",which restarts the current iteration of the active for loop which has i as
loop variable.</li> </ul>

<p>
For easier and safer program maintainance, the explicit label form is to be
preferred. Other forms are variously sensitive to changes in the program
organisation. Yet, they may prove more convenient in short, short lived
programs, an d are provided moostly for this purose.</p>

<p>
For information on how to associate a string o a block of code, see the section
on <a href="labelhdr">labelled headers</a>.  </p>

<p>
The following flow control keywords are available.  </p>

<h5>exit statement</h5>

<p>
An <strong>exit statement</strong> may appear inside a <a
href="refman_2.htm#while">while-loop</a> or a <a
href="refman_2.htm#for">for-loop</a>. It causes immediate termination of the
loop, with control passing to the first statement after the loop. e.g.</p>

<eucode>
for i = 1 to 100 do
    if a[i] = x then
        location = i
        exit
    end if
end for
</eucode>

<p>
It is also quite common to see something like this:</p>

<eucode>
constant TRUE = 1

while TRUE do
    ...
    if some_condition then
        exit
    end if
    ...
end while
</eucode>

<p>
i.e. an "infinite" while-loop that actually terminates via an <strong>exit
statement</strong> at some arbitrary point in the body of the loop. </p>

<dl>
<dt><b>Performance Note:</b></dt>
<dd>
Euphoria optimizes this type of loop.  At run-time, no test is performed at the
top of the loop. There's just a simple unconditional jump from <b>end while</b>
back to the first statement inside the loop.</dd>
</dl>

<h5>The break statement</h5>

<p>
Works exactly like the <strong>exit statement</strong>, but applies to
<strong>if statements</strong> rather than to loop statments of any kind.
Example: </p>

<eucode>
if s[1]='E' then
    a = 3
    if s[2] = 'u' then
        b = 1
        if s[3] = 'p' then
            break 0 -- leave topmost if block
        end if
        a=2
    else
	    b=4
    end if
else
    a=0
    b=0
end if
</eucode>

<p>This code resuls in:</p>

<ul>
<li>"Dur"-&gt; a=0 b=0</li>
<li>"Exe"-&gt; a=3 b=4</li>
<li>"Eux"-&gt; a=2 b=1</li>
<li>"Eup"-&gt; a=3 b=1</li>
</ul>

<h5>The continue statement</h5>

<p>
The <strong>continue statements</strong> continues execution of the loop it
applies to by going to the next iteration now. Going to the next iteration
means testing a condition (for <strong>while</strong> and <strong>loop ...
until loops</strong>, or changing the for loop variable index and checking
whether it is still within bounds.  </p>

<eucode>
for i=3 to 6 do
    ? i
    if i = 4 then
        puts(1,"(2)\n")
        continue
    end if
    ? i*i
end for
</eucode>

<p>This will print 3, 9, 4, (2), 5 25, 6 36.</p>

<h5>The retry statement</h5>

<p>
The <strong>retry statements</strong> retries executing the current iteration
of the loop it applies to. The statement branches to the first statement of the
designated loop, without testing anything nor incrementing the for loop
index.</p>

<p>
Normally, a sub-block which contains a <strong>retry statement</strong>s also
contains another flow control keyword, since otherwise the iteration would be
endlessly executed.  </p>

<eucode>
errors = 0
for i=1 to length(files_to_open) do
    fh = open(files_to_open[i],"rb")
    if fh=-1 then
        if errors>5 then
            exit
        else
            errors+=1
            retry
        end if
    end if
    file_handles[i]=fh
end for
</eucode>

<p>Since <strong>retry</strong> does not change the value of i and tries agan
opening the same file, there has to be a way to break from the loop, which the
<strong>exit statement</strong> provides.</p>

<h5>The entry statement</h5>

<p>
It is often the case that the first iteration of a loop is somehow special.
Some things have to be done before the loop starts - they are done before the
statement starting the loop -.  Now, the problem is that, just as often, some
things do not need, or should not, be done at this intialisation stage. The
<strong>entry keyword</strong> is an alternative to setting flags relentlessly
and forgetting to update them. Just add the <strong>entry</strong> kyword at
the point you wish the first iteration starts.</p>

<eucode>
global function find_all(object x, sequence source, integer from)
	sequence ret

	ret = {}
	while from > 0 entry do
		ret &= from
		from += 1
	entry
		from = find_from(x, source, from)
	end while
	return ret
end function
</eucode>

<p>Instead of performing an initial test, which may crash because from has not
been assigned a value yet, the first iteration jumps at the point where from is
being computed. The following iterations are normal. To emphasize the fat that
the first iteration is not normal, the entry clause must be addedto the loop
header, after the condition.</p>

<p>
The entry statement is not supported for for loops, because they have a more
rigid natire than while or loop constructs.  </p>

<a name="flowctrl"></a>
<h3>Labelled headers.</h3>

<p>
As shown in the above section on control flow statements, most of them may take
a string referencing a block of code. In order to do so, it is enough t do
this: </p> 

<eucode>
if n=0 label "an_if_block" then
    ...
end if
</eucode>

<p>The label clause precedes the closing then keyword.</p>
 
<p>
If a header has both an entry clause and a label clause, they have to be both
before the closing keyword, in any order: </p> 

<eucode>
while 1 label "top" entry do
-- or
while 1 entry label "top" do
</eucode>
 
<p>are both correct and equivalent.</p>

<a name="switch"></a>
<h3>The switch statement</h3>

<p>
The switch statement is often used in place  or in similar ways as an if-elsif
code block.  There are some key differences, however.  A switch statement
operates upon the value of a single expression, and the program flow continues
based upon defined cases.  The syntax of a switch statement: </p>

<eucode>
switch &lt;expr&gt; [label "&lt;label name&gt;"] do
    case &lt;val&gt;:
        [code block]
    [case else]
        [code block]
end switch
</eucode>

<p>
The &lt;val&gt; in a case must be either an atom or a literal string.  One
important difference between a switch block and an if block is that control
does not automatically go to the end of the block when the next case statement
is encountered.  This is referred to as fall-through, and allows the same code
to be used for multiple values.  'break' can be used to redirect program flow to
the end of the block.  Fall-through can also be used when different cases
require most of the same code, but one might require extra processing: </p>

<eucode>
switch length(x) do
    case 1:
    case 2:
        -- do something
    case 3:
        -- do something
        break
    case else
        -- do something
end switch
</eucode>

<a name="ifdef"></a>
<h3>The ifdef statement</h3>

<p>
The ifdef statement is unlike all of the other statements in that it is
executed at parse time not runtime. This allows you to change the way your
program operates in a very efficient manner. Since the ifdef statement works at
parse time, runtime values cannot be checked, instead special defintions can be
set or unset at parse time as well. Euphoria defines some common words itself:
</p>

<ul>
<li><strong>EU400</strong> - Version of Euphoria</li>
<li><strong>DOS32</strong> - Platform is DOS</li>
<li><strong>WIN32</strong> - Platform is Windows</li>
<li><strong>LINUX</strong> - Platform is Linux</li>
<li><strong>FREEBSD</strong> - Platform is FreeBSD</li>
<li><strong>UNIX</strong> - Platform is any Unix (currently Linux or FreeBSD)</li>
</ul>

<p>
Further, you can define your own words either in source:
</p>

<eucode>
with define=MY_WORD       -- defines
without define=OTHER_WORD -- undefines
</eucode>

<p>
or by command line:
</p>

<console>
exwc -D MY_WORD myprog.ex
</console>

<p>This can handle many tasks such as change the behavior of your application
when running on Linux vs. Windows, enable or disable debug style code or
possibly work differently in demo/shareware applications vs. registered
applications.</p>

<p>A few examples:</p>

<eucode>
for a = 1 to length(lines) do
    ifdef DEBUG then
        printf(1, "Line %i is %i characters long\n", {a, length(lines[a])})
    end ifdef
end for

sequence os_name
ifdef UNIX then
    include unix_ftp.e
elsifdef WIN32 then
    include win32_ftp.e
else
    crash("Operating system is not supported")
end ifdef

ifdef SHAREWARE then
    if record_count > 100 then
        message("Shareware version can only contain 100 records. Please register")
        abort(1)
    end if
end ifdef
</eucode>

<dl>
<dt><b>Performance Note:</b></dt>
<dd>
<p>
The ifdef statement is very efficient in that it makes the decision only once during parse
time and only emits the TRUE portions of code to the resulting interpreter. Thus, in loops
that are iterated many times there is zero performance hit when making the decision. Example:
</p>

<eucode>
while 1 do
    ifdef DEBUG then
        puts(1, "Hello, I am a debug message\n")
    end ifdef
    -- more code
end while
</eucode>

<p>
If DEBUG is defined, then the interpreter/translator actually sees the code as being:
</p>

<eucode>
while 1 do
    puts(1, "Hello, I am a debug message\n")
    -- more code
end while
</eucode>

<p>
Now, if DEBUG is not defined, then the code the interpreter/translator sees is:
</p>

<eucode>
while 1 do
    -- more code
end while
</eucode>
</dd>
</dl>

<h2>Short-Circuit Evaluation</h2>

<p>
When the condition tested by if, elsif, until, or while contains and or or
operators, <i>short-circuit</i> evaluation will be used.  For example,</p>

<eucode>
if a < 0 and b > 0 then ...
</eucode>

<p>
If a < 0 is false, then Euphoria will not bother to test if b is greater
than 0. It will assume that the overall result is false. Similarly,</p>

<eucode>
if a < 0 or b > 0 then ...
</eucode>

<p>
if a < 0 is true, then Euphoria will immediately decide that the result true,
without testing the value of b.</p>

<p>
In general, whenever we have a condition of the form:</p>

<eucode>
A and B
</eucode>

<p> 
where A and B can be any two expressions, Euphoria will take a short-cut when A
is false and immediately make the overall result false, without even looking at
expression B.</p>

<p>
Similarly, with:</p>

<eucode>
A or B
</eucode>

<p>
when A is true, Euphoria will skip the evaluation of expression B, and declare
the result to be true.</p>

<p>
If the expression B contains a call to a function, and that function has
possible <b>side-effects</b>, i.e. it might do more than just return a value,
you will get a compile-time warning. Older versions (pre-2.1) of Euphoria did
not use <strong>short-circuit</strong> evaluation, and it's possible that some
old code will no longer work correctly, although a search of the Euphoria
archives did not turn up any programs that depend on side-effects in this
way.</p>

<p>
The expression, B, could contain something that would normally cause a run-time
error. If Euphoria skips the evaluation of B, the error will not be discovered.
For instance:</p>

<eucode>
if x != 0 and 1/x > 10 then  -- divide by zero error avoided

while 1 or {1,2,3,4,5} do    -- illegal sequence result avoided
</eucode>

<p>B could even contain uninitialized variables, out-of-bounds subscripts
etc.</p>

<p>
This may look like sloppy coding, but in fact it often allows you to write
something in a simpler and more readable way. For instance:</p>

<eucode>
if atom(x) or length(x)=1 then
</eucode>

<p>Without short-circuiting, you would have a problem when x was an atom, since
length is not defined for atoms. With short-circuiting, length(x) will only be
checked when x is a sequence. Similarly:</p>

<eucode>
-- find 'a' or 'A' in s
i = 1
while i <= length(s) and s[i] != 'a' and s[i] != 'A' do
     i += 1
end while
</eucode>

<p>In this loop the variable i might eventually become greater than length(s).
Without short-circuit evaluation, a subscript out-of-bounds error will occur
when s[i] is evaluated on the final iteration. With short-circuiting, the loop
will terminate immediately when i <= length(s) becomes false. Euphoria will not
evaluate s[i] != 'a' and will not evaluate s[i] != 'A'. No subscript error will
occur.</p>

<p>
<strong>Short-circuit</strong> evaluation of and and or takes place for if,
elsif and while conditions only.  It is not used in other contexts. For
example, the assignment statement:</p>

<eucode>
x = 1 or {1,2,3,4,5}  -- x should be set to {1,1,1,1,1}
</eucode>

<p>If short-circuiting were used here, we would set x to 1, and not even look
at {1,2,3,4,5}. This would be wrong. Short-circuiting can be used in
if/elsif/until/while conditions because we only care if the result is true or
false, and conditions are required to produce an atom as a result.</p>

<p> The first iteration of a while loop is often special, because some work
still doesn't need to be done. As a result, ou have to keep track of whether
you are in the initialisation stage or not, and usually test a flag on every
iteration of the loop, while this will be useful only once. Not needed, and
another cause of programming errors.  In addition, and also because repetition
of code often takes place as a result of the flag weving method, Euphoria
provides a special entry keyword to better handle this situation.</p>

<p>
The entry keyword will be described in the section on <a href="refman_2.htm#flowctrl">
 instruction flow control</a>. To use it, you will
need an entry tag in the loop header, as a clue to any reader that the first
iteration of the loop willn not start right after the closing do.  </p>

<h2>Note on infinite loops.</h2>

<p>
With <strong>ex.exe</strong>, if you happen to create a real infinite loop,
with no input/output taking place, there is no easy way to stop it. You will
have to type Control-Alt-Delete to either reboot, or (under Windows) terminate
your DOS prompt session. If the program had files open for writing, it would be
advisable to run <b>scandisk</b> to check your file system integrity.  Only
when your program is waiting for keyboard input, will control-c abort the
program (unless <a href="lib_file.htm#allow_break">allow_break(0)</a> was
used).</p>

<p>
With <strong>exw.exe</strong> or <strong>exu</strong>, control-c will always
stop your program immediately.</p>

<h2>Miscellaneous statements</h2>
<h3>The warning() procedure</h3>
<p>
 Writing a library has specific requirements, since the code you write will be mainly used
 inside code you didn't write. It may be desirable then to influence, from inside the library,
 that code you didn't write.
 </p>
 <p>
 This is what warning(), in a limited way, does. It enables to generate custom warnings in
 code that will include yours. Of course, you can also geenrate warnings in your own code, for
 instance as a kind of memo. The without warning top level statement disables such warnings.
 </p>
 <p>
 Example:</p>
 <eucode>
 -- mylib.e
 procedure foo(integer n)
 warning("The foo() procedure is obsolete, use bar() instead.")
 ?n
 end procedure

 -- some_app.exw
 include mylib.e
 foo(123)
 </eucode>
 will result, when some_app.exw is run with warning, in the following text being displayed in the console window:
 <pre>
 123
 Warning: The foo() procedure is obsolete, use bar() instead.

 Press Enter...
 </pre>
<p>
<b>N.B.: </b>the argument to warning() is a single literal constant enclosed in double quotes, like above. Using any kind of variable or expression will result in a blank warning.
</p>

<h3>The warning_file() proceduure</h3>
<p>
Just as for the error file, you can redirect any warnings which are not masked - either 
because they cannot or were not - using warning_file(<em>destination</em>), with an extra 
twist:
<ul>
<li>If <em>destination</em> is a sequence, it is assumed to be a file name, and all warnings will go there instead of the console;</li>
<li>If <em>destination</em> is a nonnegative atom, the standard error will be used, which is the default behaviour;</li>
<li>If <em>destination</em> is a negative atom, any warning generation or output will be suppressed, including for otherwise non maskable warnings. This is an extreme measure which should be taken in very rare cases only. Use a warning file as much as possible.</li>
</ul>
</p>

<h2>Special Top-Level Statements</h2>

<p>
Before any of your statements are executed, the Euphoria front-end quickly
reads your entire program. All statements are syntax checked and converted to a
low-level intermediate language (IL).  The interpreter immediately executes the
IL. The translator  converts the IL to C. The binder/shrouder saves the IL on
disk for later execution. These three tools all share the same front-end
(written in Euphoria).</p>

<p>
If your program contains only routine and variable declarations, but no
top-level executable statements, then nothing will happen when you run it
(other than syntax checking). You need a top-level statement to call your main
routine (see <a href="refman_1.htm#1">1.1 Example Program</a>).  It's quite
possible to have a program with nothing but top-level executable statements and
no routines. For example you might want to use Euphoria as a simple calculator,
typing just a few <a href="lib_file.htm#print">print</a> (or <a
href="lib_file.htm#?">?</a>) statements into a file, and then executing it.
</p>

<p>
As we have seen, you can use any Euphoria <a
href="refman_2.htm#5">statement</a>, including <a
href="refman_2.htm#for">for-loops</a>, <a
href="refman_2.htm#while">while-loops</a>, <a href="refman_2.htm#if">if</a>
statements etc. (but not <a href="refman_2.htm#return">return</a>), at the top
level i.e.  <i>outside</i> of any <a href="refman_2.htm#412">function</a> or <a
href="refman_2.htm#411">procedure</a>.  In addition, the following special
statements may <i>only</i> appear at the top level:</p>

<ul>
<li>include</li>
<li>with / without</li>
</ul>

<h3>include</h3>

<p>
When you write a large program it is often helpful to break it up into
logically separate files, by using <strong>include statements</strong>.
Sometimes you will want to reuse some code that you have previously written, or
that someone else has written. Rather than copy this code into your main
program, you can use an <strong>include statement</strong> to refer to the file
containing the code. The first form of the include statement is:</p>

<dl>
<dt><strong>include <i>filename</i></strong></dt>
<dd>
<p>This reads in (compiles) a Euphoria source file.</p>
<p>Some Examples:</p>

<eucode>
include graphics.e
include \mylib\myroutines.e
export include library.e
</eucode>

<p>Any top-level code in the included file will be executed.</p>

<p>
Any <a href="refman_2.htm#scope">global symbols</a> that have already been
defined in the main file will be visible in the included file.</p>

<p>
<b>N.B.</b> Only those symbols defined as <a href="refman_2.htm#scope">global
or export</a> in the included file will be visible (accessible) in the
remainder of the program.  </p>

<p>
If export precedes the include statement, then all exported symbols from the
included file will also be exported from the current file, and visible to any
file that includes the current file. </p>

<p>
If an absolute <i>filename</i> is given, Euphoria will open it and start
parsing it. When a relative <i>filename</i> is given, Euphoria will try to open
the file relative to the following directories, in the following order:</p>

<ol>
<li> 
The directory containing the current source file.  i.e. the source file that
contains the include statement that is being processed..</li>

<li> 
The directory containing the main file given on the interpreter, translator or
binder <a href="refman_1.htm#3">command-line</a>.</li>

<li> 
If you've defined an environment variable, <env>EUINC</env>, Euphoria will
check each directory listed in <env>EUINC</env> (from left to right).
<env>EUINC</env> should be a list of directories, separated by semicolons
(colons on <platform>Linux</platform> / <platform>FreeBSD</platform>), similar
in form to your <env>PATH</env> variable. <env>EUINC</env> can be added to your
set of <platform>Linux</platform> / <platform>FreeBSD</platform> or
<platform>DOS</platform> / <platform>Windows</platform> environment  variables.
(Via <gui>Control Panel / Performance & Maintenance / System / Advanced</gui>
on <platform>XP</platform>, or <path>AUTOEXEC.BAT</path> on older versions of
<platform>Windows</platform>).  e.g.

<console>
SET EUINC=C:\EU\MYFILES;C:\EU\WIN32LIB
</console>

<env>EUINC</env> lets you organize your include files according to application
areas, and avoid adding numerous unrelated files to <path>euphoria\include</path>.</li>

<li> 
Finally, if it still hasn't found the file, it will look in
<path>euphoria\include</path>.  This directory contains the standard Euphoria
include files. The environment variable <env>EUDIR</env> tells Euphoria where
to find your <path>euphoria</path> directory.</li>

</ol>

<p>
An included file can include other files. In fact, you can "nest" included
files up to 30 levels deep.</p>

<p>
Include file names typically end in <path>.e</path>, or sometimes
<path>.ew</path> or <path>.eu</path> (when they are intended for use with
<platform>Windows</platform> or <platform>Linux</platform>).  This is just a
convention. It is not required.</p>

<p>
If your filename (or path) contains blanks, you must enclose it in
double-quotes, otherwise quotes are optional.  Also, be sure to double-up your
backslashes.  For example:</p>

<eucode>
include "c:\\program files\\myfile.e"
</eucode>

<p>
Other than possibly defining a new namespace identifier (see below), an include
statement will be quietly ignored if the same file has already been
included.</p>

<p>
An include statement must be written on a line by itself.  Only a comment can
appear after it on the same line.</p>

</dd>
</dl>

<p>The second form of the include statement is:</p>

<dl>
<dt>
<strong>include</strong> <b><i>filename</i> as <i>namespace_identifier</i></b></dt>

<dd>
<p>
This is just like the simple include, but it also defines a <i>namespace
identifier</i> that can be attached to global symbols in the included file that
you want to refer to in the main file. This might be necessary to disambiguate
references to those symbols, or you might feel that it makes your code more
readable.  See <a href=refman_2.htm#42>Scope Rules</a> for more.</p>
</dd>
</dl>

<h3>with / without</h3>

<p>
These special statements affect the way that Euphoria translates your program
into internal form. They are not meant to change the logic of your program, but
they may affect the diagnostic information that you get from running your
program.  See <a href="refman_3.htm">3. Debugging and Profiling</a> for more
information.</p>

<dl>
<dt>
<strong>with</strong></dt>

<dd>
<p>
This turns <b>on</b> one of the options: <b> 
<a href="refman_3.htm#2">profile</a>, 
<a href="refman_3.htm#2">profile_time</a>, 
<a href="lib_dbg.htm#trace">trace</a>, warning</b>, 
<a href="refman_2.htm#typechk"><b>type_check</b></a> and
<a href="#ifdef"><b>define=WORD</b></a>.  

Options <strong>warning</strong> and <strong>type_check</strong> are initially on,
while <strong>profile</strong>, <strong>profile_time</strong> and
<strong>trace</strong> are initially off.</p>

<p>
Any warnings that are issued will appear on your screen after your program
has finished execution. Warnings indicate very minor problems.  A warning will
never stop your program from executing. You will simply have to hit the Enter key to keep going.</p></dd>

<dt><strong>without</strong></dt>

<dd>This turns <b>off</b> one of the above options.</dd>
</dl>

<p>
There is also a rarely-used special <strong>with</strong> option where a code
number appears after <strong>with</strong>.  In previous releases this code was
used by RDS to make a file exempt from adding to the statement count in the old
"Public Domain" Edition.</p>

<p>
You can select any combination of settings, and you can change the settings,
but the changes must occur <i>between</i> subroutines, not within a subroutine.
The only exception is that you can only turn on one type of profiling for a
given run of your program.</p>

<p>
An <b>included file</b> inherits the <strong>with/without</strong> settings in
effect at the point where it is included.  An included file can change these
settings, but they will revert back to their original state at the end of the
included file.  For instance, an included file might turn off warnings for
itself and (initially) for any files that it includes, but this will not turn
off warnings for the main file.</p>

<p>
Actually, there are two sorts of warnings: maskable and not maskable ones. The not maskable ones are not supposed to occur in production code. As a result, they are not suppressed by the
<strong>without warning</strong> directive. Maskable warnings can be turned on and off individually.</p>
<p>
<strong>without warning</strong> not only turns off maskable warnings, it saves the current state of the warning mask. <strong>with warning</strong> simply restores that mask. Initially,
onlly the warnings concerning non explicitly included symbols, overriding a builtin routine and choosing a builtin routine over another global symbol. This can be changed using -W command line switches.</p>
<p>
The <strong>with warning</strong> has optional extensions in order to customise maskable warnings:
<ul>
<li><strong>with warning</strong>=<em>warning names</em> enables only these warnings, and disable all other;</li>
<li><strong>with warning</strong>+=<em>warning names</em> enables listed warnings in addition to whichever are enabled already;</li>
<li><strong>with warning</strong>-=<em>warning names</em> disables listed warnings and leaves anyone not listed in its current state.</li>
</ul></p>
<p>
The following names are known:
<dl>
<dt>"no_warning"</dt>
<dd>suppresses all maskable warnings, without saving the earlier state
</dd>
<dt>"resolution_warning"</dt>
<dd>a symbol was used in a file, but was defined in a file this file doesn't include
</dd>
<dt>"sc_warning"</dt>
<dd>a routine call may not take place because of short circuit evaluation in a conditional clause
</dd>
<dt>"override_warning"</dt>
<dd>a builtin is being overridden
</dd>
<dt>"builtin_chosen_warning"</dt>
<dd>an unqualified call caused Eupjoria to choose between a builtin and another gobal which 
does not override it. Euphoria chooses the builtin.
</dd>
<dt>"not_used_warning"</dt>
<dd>A variable has not been used and is going out of scope
</dd>
<dt>"no_value_warning"</dt>
<dd>A variable never got assigned a value and is going out of scope
</dd>
<dt>"custom_warning"</dt>
<dd>Any warning that was defined using this special level in the warning() procedure.
</dd>
<dt>"lint_warning"</dt>
<dd>Turns all maskable warnings on.
</dd>
</dl>
They must always appear between double quotes, except when used in a -W command line switch.
</p>

<h2>Command line switches</h2>

<p>
You can launch Euphoria with some extra command line switches, in order to add or change 
configuration elements. When running a GUI, there is always some way to open a prompt and 
enter any text with options, arguments and whatever the program being launched may need for 
proper, expectd operation. Under <platform>Windows</platform>, this s achieved by clicking the 
Run... start menu entry, or hitting Windows-R.</p>

<p>
The following items may be changed or added, one at a time:</p>
<dl>
<dt>-C cofig_file</dt>
<dd>Specifies the path for a file called euinc.conf, which holds a set of include paths, one on each line.</dd>
<dt>-I include_path</dt>
<dd>Specifies an extra include path.</dd>
<dt>-D tag</dt>
<dd>Defines a tag as being set. Tags are processed by <strong>ifdef</strong> blocks.</dd>
<dt>-W warning_name</dt>
<dd>Resets, or adds to, the current list of maskable wrnings that will be emitted. The list of known names is to be found in the subsection describing <strong>with warning</strong>. A name should appear without quotes. The first -W switch resets the list to the warning being introduced, and each subsequent -> switch adds to the list.</dd>
</dl>
<p>The case of the switches is ignored, so -I and -i are equivalent, and so on.</p>
<p>
Further notes:
<ul>
<li>
Included files are searched for in all included paths, in the following order:
<ol>
<li>The current path</li>
<li>Paths specified in a -I command line switch</li>
<li>Paths specified in euinc.conf</li>
<li>Paths listed in the EUINC environment variable, in the order in which they appear</li>
<li>Paths listed in the EUDIR environment variable, in the order in which they appear</li>
<li>The interpreter's path</li>
</ol>
</li>
<li>The euinc.conf (Windows) / .euinc.conf (Linux/FreeBSD) file, if not specified using the -C command line switch, is searched for in:</li>
<ol>
<li>The interpreter's path</li>
<li>
<ul>
<li>Linux/FreeBSD: The directory specified in the HOME  environment variable</li>
<li>Windows: The "euphoria" subfolder of the directory specified in the APPDATA environment variable</li>
</ul></li>
<li> 
<ul>
<li>Linux/FreeBSD: The /etc/euphoria path</li>
<li>Windows: The "euphoria" subfolder of the directory specified in the ALLUSERSPROFILE environment variable</li>
</ul></li>
</ol>
euinc.conf is not supported under DOS, except through the -C command line switch.
</li>
<li>
The initial list of maskable, unmasked warnings is:
<ul>
<li>resolution_warning</li>
<li>override_warning</li>
<li>builtin_chosen_warning</li>
</ul></li>
<li>Any number of any switch many appear in any order on the command line. However, only the euinc.conf file specified last will be inspected.</li>
</ul>
</p></doc>








