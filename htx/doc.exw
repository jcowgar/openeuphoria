-- (c) Copyright 2007 Rapid Deployment Software - See License.txt

-- Documentation Generator
-- written by: Junko C. Miura of Rapid Deployment Software 
-- (JCMiura@RapidEuphoria.com)

-- TODO: fix output of all sections (example 2, 3, 4, etc...)
-- TODO: add docs on how to document euphoria to wiki?

include get.e
include misc.e
include file.e
include map.e as m

constant single_tags = { "br", "hr", "br/", "hr/" }

sequence files 
files = {
    "welcome.htx",
    "overview.htx",
    "install.htx",
    "what2do.htx",
    "miniguid.htx",
    "bind.htx",
    "c.htx",
    "cgi.htx",
    "database.htx",
    "e2c.htx",
    "trouble.htx",
    "relnotes40.htx",
    "refman_1.htx",
    "refman_2.htx",
    "refman_3.htx"
}

include stack.e as stk
stk:stack format_stack
format_stack = stk:new(FILO)

global function in_tag(sequence tag)
    integer nesting_count
    sequence top_tag

	nesting_count = 0
	for i = stk:size(format_stack) to 1 by -1 do
		top_tag = stk:at(format_stack, i)
		nesting_count += equal(tag, top_tag[1])
	end for
	
	return nesting_count
end function

global function is_tag(sequence tag)
	sequence top_tag
	top_tag = stk:top(format_stack)
	return equal(tag, top_tag[1])
end function

without warning
include docgen.e   -- common include file for RTF, HTML, and plain text
include html.e     -- output format: HTML

-- EUDIR might not be set, shroud should be ok
include wildcard.e  
with warning
with trace
function param_list(object text)
-- read an HTMX tag and extract all the parameters and their values.
-- text must contain a '>' at the end, or text may be an atom.
-- format of text, before '>', when it is not an atom, should be:  
--           name1(=value1) name2(=value2) ...
--        where () means optional
	integer i, value_part
	sequence word, list
	
	if atom(text) then
	return {}
	end if

	list = {}
	i = 1
	value_part = FALSE
	while TRUE do
		while whitespace(text[i]) do
			i = i + 1
		end while
		if text[i] = '>' then
			exit
		end if
		if text[i] = '=' then
			i = i + 1   
			value_part = TRUE
			while whitespace(text[i]) do
			i = i + 1
			end while
		end if
	
		if text[i] = '"' then
			-- read quoted-string parameter
			word = ""
			i = i + 1
			while text[i] != '"' and i < length(text) do
			if text[i] = '\\' then
				if text[i + 1] = '"' then
				word = word & text[i + 1]
				else
				word = word & text[i] & text[i + 1]
				end if
				i = i + 2
			else
				word = word & text[i]
				i = i + 1
			end if
			end while
			if text[i] = '"' then
			i = i + 1
			end if
		else 
			word = ""
			while not whitespace(text[i]) and text[i] != '=' and 
				text[i] != '>' do
			word = word & text[i]
			i = i + 1
			end while
		end if
		if value_part then
			-- make a pair
			list[length(list)] = {list[length(list)], word}
			value_part = FALSE
		else
			list = append(list, word)
		end if
	end while
	return list
end function

procedure tag(sequence name, object param, object raw)
-- process a tag (or literal text)
	integer r
	sequence top_tag
	
	-- handle format stack
	if equal(name, "_literal") then
		-- do nothing
	elsif name[1] = '/' then
		if is_tag(name[2..$]) = 0 then
			top_tag = stk:top(format_stack)
			
			printf(1, "Document error on line %d. Found %s when expecting /%s (began at %d)\n",
			{current_line, name, top_tag[1], top_tag[2]})
			if platform() = WIN32 then
			puts(1, "Press any key to continue...\n")
			r = wait_key()
			end if
			abort(1)
		end if
	
		format_stack = stk:pop(format_stack)
	elsif find(name, single_tags) then
	-- neither push nor pop, this is <br /> or something to that effect
	else
	
	format_stack = stk:push(format_stack, {name, current_line})
	end if
	
	r = find(name, handler_name)
	if r = 0 then
		r = find("_default", handler_name)
		if r = 0 then
			quit("Need a default handler")
		end if
	end if
	
	if equal(name, "!--") then
		call_proc(handler_id[r], {raw, ""})
	else
		call_proc(handler_id[r], {raw, param_list(param)})
	end if
end procedure

procedure scan()
	integer c, inDQuote
	sequence raw, name, param
	
	while TRUE do
		c = getc(in_file)
		
		if c = '\n' then current_line += 1 end if
		
		if c = EOF then
			exit
		elsif c = '<' then
			-- an htmX tag?
			c = getc(in_file)
			if whitespace(c) or c = '=' then
				tag("_literal", '<', '<')
				tag("_literal", c, c)
			else
				raw = "<"
				
				-- read the name
				name = ""
				while not whitespace(c) and c != '>' and c != EOF do
					name = name & c
					c = getc(in_file)
				end while
				name = lower(name)
				raw = raw & name
			
				-- read the parameter list (if any)
				param = ""
				inDQuote = FALSE
				while not inDQuote and c != '>' and c != EOF do
					if c = '"' then
					inDQuote = TRUE
					param = param & c
					c = getc(in_file)
					while inDQuote and c != EOF do
						if c = '"' then
						inDQuote = FALSE
						elsif c = '\\' then  
						-- control char. Just read in the next char.
						param = param & c
						c = getc(in_file) -- c might be EOF, watch...  
						end if
						param = param & c   -- so, c may be EOF, but ok
						c = getc(in_file)   --   because it will be caught.
					end while
					else
					param = param & c
					c = getc(in_file)
					end if
				end while
			
				if inDQuote then       -- checking inDQuote first makes sense
					quit("double quote never closed") 
				elsif c = '>' then
					param = param & '>'
					raw = raw & param 
					tag(name, param, raw)
				elsif c = EOF then
					quit("premature EOF")
				end if
			end if
		else
			tag("_literal", c, c)
		end if
	end while
end procedure

sequence app_dir

procedure init_dir()
	sequence cmd_line, format
	integer param
	cmd_line = command_line()
	
	format = "HTML"
	html_init()
	
	cmd_line = cmd_line[1..2] & cmd_line[4..length(cmd_line)]
	
	if length(cmd_line) >= 4 then
		-- space in path and forgot quotes
		app_dir = cmd_line[3]
		param = 4
		while param <= length(cmd_line) do
			app_dir = app_dir & " " & cmd_line[param]
			param += 1
		end while
	elsif length(cmd_line) = 3 then
		app_dir = cmd_line[3]
	else
		-- If not passed, then assume normal source directory structure
		app_dir = ".."
	end if
	
	app_dir &= PATHSEP
	app_dir = app_dir
end procedure

procedure generate(sequence in_name, sequence format, sequence dest)
	sequence out_name
	integer p
	if not match(".htx", in_name) then
		quit("must be a .htx file")
	end if
	in_file = open(in_name, "r")
	if in_file = -1 then
		quit("couldn't open " & in_name & " for reading")
	end if
	
	current_file = in_name
	current_line = 0
	p = find('.', in_name)
	
	out_name = in_name[1..p] & out_type
	if find('_', out_name) and equal(format, "PLAIN") then

	
	elsif match("readme.", out_name) then
		out_name = app_dir & PATHSEP & out_name
	elsif equal("lib_0.htm", out_name) then
		out_name = app_dir & PATHSEP & "html" & PATHSEP & "library.htm"
	elsif equal("refman_0.htm", out_name) then
		out_name = app_dir & PATHSEP & "html" & PATHSEP & "refman.htm"
	else    
		out_name = app_dir & dest & PATHSEP & out_name
	end if
	
	out_file = open(out_name, "w")
	if out_file = -1 then
		quit("couldn't open " & out_name & " for writing")
	end if
	
	printf(1,"Processing %s\n", {in_name})
	scan()
	
	close(in_file)
close(out_file)
end procedure


procedure toc_and_menu()
	-- Output Table of Contents and Menu
	sequence s
	integer toc_file, menu_file, ign
	toc_file = open("../html/toc.htm", "w")
	menu_file = open("../html/menu.htm", "w")
	puts(toc_file, "<html><body><h1>Table of Contents</h1>\n")
	ign = write_lines(menu_file,
	{"<html><head><style>",
	"body { background-color: #efefef; }",
	"h2 { margin-bottom: 0px; padding-bottom: 0px; border-bottom: 2px solid black; }",
	"a, a:visited { color: #555; text-decoration: none; }",
	"div.menu { font-size: small; }",
	"div.title { font-weight: bold; padding-top: 15px; padding-bottom: 2px; }",
	"div.one { margin-top: 2px; padding-top: 2px; padding-left: 10px; }",
	"div.two { margin-top: 2px; padding-top: 2px; padding-left: 20px; }",
	"</style></head>",
	"<body><div class=\"menu\">",
	"<h2 align=\"center\">Euphoria v4.0</h2>"})
	
	for i = 1 to length(sections) do
		s = secnum_seq(sections[i][2])
		
		-- Only output top 3 levels for TOC
		if length(s) <= 3 then
			if length(s) = 1 then
				puts(toc_file, "<strong><font size=+1>")
				puts(menu_file, "<div class=\"title\">")
			elsif length(s) = 2 then
				puts(toc_file, "&nbsp;&nbsp;&nbsp;&nbsp;")
				puts(menu_file, "<div class=\"one\">&#187; ")
			elsif length(s) = 3 then
				puts(toc_file, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>")
			end if
			printf(toc_file, "<a href=\"%s\">%s</a><br />", 
				{sections[i][1][1..$-3] & "htm", join(s, ".") & ". " & sections[i][3]})
			if length(s) <= 2 then
				printf(menu_file, "<a target=\"page\" href=\"%s\">%s</a><br />", 
					{sections[i][1][1..$-3] & "htm", sections[i][3]})
			end if
			if length(s) = 1 then
				puts(toc_file, "</font></strong>")
				puts(menu_file, "</div>")
			elsif length(s) = 2 then
				puts(menu_file, "</div>")
			elsif length(s) = 3 then
				puts(toc_file, "</i>")
			end if
		end if
	end for
	
	puts(toc_file, "</body></html>\n")
	puts(menu_file, "</div></body></html>\n")
	close(toc_file)
	close(menu_file)
end procedure

procedure scan_includes()
	sequence files

	files = dir("../include/*.e")
	for a = 1 to length(files) do
		process_include("../include/" & files[a][1])
	end for
end procedure

function compare_func(object a, object b)
	return compare(m:get(a, "name", ""), m:get(b, "name", ""))
end function

procedure sort_includes()
	integer rid
	
	rid = routine_id("compare_func")
	functions = sort(functions)

	for a = 1 to length(functions) do
		functions[a][2] = custom_sort(rid, functions[a][2])
	end for
end procedure

function format_para(sequence p)
	p = trim(p, " \r\n\t")
	if match("\n\n", p) then
		p = "<p>" & find_replace("\n\n", "</p>\n<p>", p, 0) & "</p>"
	end if
	return p & '\n'
end function

function get_section(m:map func, sequence section, sequence tag, integer wrap, integer say_none)
	sequence val
	val = m:get(func, section, "")
	if length(val) = 0 then
		if say_none then
			val = "none"
		else
			return ""
		end if
	end if
	
	if wrap then
		val = format_para(val)
	end if

	return sprintf("<%s>%s</%s>\n", {tag, val, tag})
end function

procedure write_includes()
	object ign, content
	sequence cat_name, api_content, typ
	m:map func, cat

	for a = 1 to length(functions) do
		cat_name = functions[a][1]
		if length(cat_name) = 0 then continue end if

		cat = m:get(categories, cat_name, m:new())
		files &= {"lib_" & cat_name & ".htx"}

		content = read_file("t_lib_" & cat_name & ".htx")
		if atom(content) then
			content = sprintf("<doc title=\"%s\">\n\n<h2>%s</h2>\n\n$(API)\n\n</doc>", {
					m:get(cat, "title", sprintf("%s needs title assigned", {cat_name})),
					m:get(cat, "title", sprintf("%s needs title assigned", {cat_name}))
				})
		end if
		api_content = ""
		for b = 1 to length(functions[a][2]) do
			func = functions[a][2][b]
			typ = m:get(func, "type", "")
			
			api_content &= sprintf("<funcref name=\"%s\" type=\"%s\" params=\"%s\">\n", {
				m:get(func, "name", ""), typ, m:get(func, "params", "none") })
			if equal(typ, "function") then
				api_content &= get_section(func, "returns", "funcreturns", 1, 1)
			end if
			api_content &= get_section(func, "description", "funcdescr", 1, 0)
			api_content &= get_section(func, "comments", "funccomments", 1, 0)
			for c = 1 to 10 do
				if m:has(func, "example " & sprint(c)) then
					api_content &= sprintf("<eucode title=\"Example %d\">\n%s\n</eucode>\n",
						{c, m:get(func, "example " & sprint(c), "")})
				end if
			end for
			api_content &= get_section(func, "see also", "funcseealso", 1, 0)
			api_content &= "</funcref>\n"
			
		end for
		
		content = find_replace("$(API)", api_content, content, 1)
		ign = write_file("lib_" & cat_name & ".htx", content)
	end for
end procedure

procedure main()
	init_dir()
	scan_includes()
	sort_includes()
	write_includes()
	combined_file = open("../html/combined.htm", "w")
	for f = 1 to length(files) do
		generate(files[f], "HTML", "html")
	end for
	close(combined_file)
	toc_and_menu()
end procedure

main()

