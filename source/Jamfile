SubDir TOP source ;

#
# Setup compiler specific flags
#

if $(JAM_TOOLSET) = WATCOM
{
    CCFLAGS = /bt=nt /mf /w0 /zq /j /zp4 /fp5 /fpi87 /5r /otimra /s /ol /zp4 /dEWATCOM /dEOW ;
    EUCFLAGS = -wat ;
}
else if $(JAM_TOOLSET) = VISUALC
{
    CCFLAGS = -D_CRT_NONSTDC_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DEMSVC ;
}
else if $(JAM_TOOLSET) = MINGW
{
    CCFLAGS = -w -ffast-math -O2 -Os -DEMINGW -mno-cygwin -mwindows ;
    EUCFLAGS = -gcc ;
}
else
{
    CCFLAGS = -w -ffast-math -O2 -Os ;
}

CCFLAGS += -DHAVE_CONFIG_H ;

#
# Setup platform specific flags
#

if $(NT)
{
    CCFLAGS += /dEWINDOWS ;
}
else if $(UNIX)
{
    CCFLAGS += -DEUNIX ;
    if $(OS) = MACOSX
    {
        CCFLAGS += -DEBSD -DEBSD62 -DEOSX ;
    }
    else if $(OS) = FREEBSD
    {
        CCFLAGS += -DEBSD -DEBSD62 -DEFREEBSD ;
    }
    else if $(OS) = OPENBSD
    {
        CCFLAGS += -DEBSD -DEBSD62 -DEOPENBSD ;
    }
    else if $(OS) = NETBSD
    {
        CCFLAGS += -DEBSD -DEBSD62 -DENETBSD ;
    }
    else if $(OS) = LINUX
    {
        CCFLAGS += -DELINUX ;
    }
    else
    {
        Echo $(OS) is not supported by Euphoria ;
        Exit ;
    }
}
else
{
    Echo $(OS) is not supported by Euphoria ;
    Exit ;
}

#
# Special flags for PCRE
#

CCFLAGS += -DNO_RECURSE ;

#
# Configuration Flags
#

if $(MANAGED_MEMORY) = "on" {
    EUCFLAGS +=  -D EU_MANAGED_MEM ;
    CCFLAGS += -dMANAGED_MEM ;
}

if $(DEBUG) = "on" {
    EUCFLAGS += -D DEBUG ;
    CCFLAGS += -dDEBUG ;
}

#
# Generates be_ver.h
#

BE_VER_H = [ FDirName $(BUILD_DIR) be_ver.h ] ;
BE_VER_CACHE = [ FDirName $(BUILD_DIR) be_ver.cache ] ;

rule BeVer
{
    Clean clean : $(<) ;
    Depends $(>) : $(<) ;
	Depends $(<) : mkver ;

	MKVER on $(<) = [ FDirName $(BUILD_DIR) mkver$(SUFEXE) ] ;
}

actions BeVer
{
    $(MKVER) hg $(BE_VER_CACHE) $(BE_VER_H)
}

#
# Generate the be_magic.c file
#

rule MagicGet
{
    Depends $(<) : $(>) ;
    Clean clean : $(<) ;
    MakeLocate $(<) : [ FDirName $(BUILD_DIR) $(SOURCE_GRIST) ] ;

    FINDJMP on $(<) = [ FDirName $(TOP) source findjmp.ex ] ;
}

actions MagicGet
{
    eui $(FINDJMP) $(<) $(>)
}

#
# Define a few variables containing our C source file listings
#

PCRE_SOURCES = [ Glob [ FDirName $(TOP) source pcre ] : *.c ] ;
EU_LIB_SOURCE = be_alloc.c be_callc.c be_coverage.c be_decompress.c be_inline.c be_machine.c be_pcre.c
    be_runtime.c be_socket.c be_syncolor.c be_task.c be_w.c ;
EU_BACKEND_SOURCE = $(EU_LIB_SOURCE) be_execute.c be_main.c be_rterror.c be_symtab.c ;

SEARCH_SOURCE += [ FDirName $(SUBDIR) pcre ] ;
SEARCH_SOURCE += [ FDirName $(BUILD_DIR) ] ;

if $(JAM_TOOLSET) = WATCOM
{
    EU_BACKEND_SOURCE += be_magic.c ;
}

#
# SOURCE_GRIST enables us to use the same source file
# with different compiler settings
#
# LOCATE_TARGET causes all built files to be located
# in a given directory
#
# MakeLocate causes the final output to be written to
# yet a different directory. This allows us to use
# LOCATE_TARGET to place all the .o/.obj files into
# a sub directory of the BUILD_DIR and the final
# resulting .a/.lib files directly into the BUILD_DIR
#

#
# Build the mkver program
#

LOCATE_TARGET = [ FDirName $(BUILD_DIR) ] ;
Main mkver : mkver.c ;

#
# Build the eu.a/eu.lib file
#

SOURCE_GRIST = eu ;
LOCATE_TARGET = [ FDirName $(BUILD_DIR) eu ] ;
BeVer $(BE_VER_H) : <eu>be_machine$(SUFOBJ) ;
MagicGet <eu>be_magic.c : <eu>be_execute$(SUFOBJ) ;
Library eu : $(EU_BACKEND_SOURCE) $(PCRE_SOURCES:BS) ;
MakeLocate eu$(SUFLIB) : $(BUILD_DIR) ;
InstallLib bin : eu$(SUFLIB) ;

#
# Build a utility library of the backend. This saves us compiling
# time as it will be generated once and then linked into a few
# different binaries.
#

SOURCE_GRIST = ebackend ;
LOCATE_TARGET = [ FDirName $(BUILD_DIR) ebackend ] ;
CCFLAGS += -DEBACKEND ;
Library ebackend : $(EU_BACKEND_SOURCE) $(PCRE_SOURCES:BS) ;
MakeLocate ebackend$(SUFLIB) : [ FDirName $(BUILD_DIR) ] ;
BeVer $(BE_VER_H) : <ebackend>be_machine$(SUFOBJ) ;
MagicGet <ebackend>be_magic.c : <ebackend>be_execute$(SUFOBJ) ;

#
# Add the $(TOP)/include directory to the search path for source
# files. This way, automatic dependency scanning can find include
# files and cause our targets to recompile when they change.
#

SEARCH_SOURCE += [ FDirName $(TOP) include ] ;

SOURCE_GRIST = ;

#
# Our actual build targets
#

USER_LIBRARY = [ FDirName $(BUILD_DIR) ebackend ] ;

EuMain eui : [ FDirName $(SUBDIR) int.ex ] ;
#EuWinMain euiw : [ FDirName $(SUBDIR) int.ex ] ;
#EuMain eub : [ FDirName $(SUBDIR) backend.ex ] ;
#EuWinMain eubw : [ FDirName $(SUBDIR) backend.ex ] ;
#
#InstallBin bin : eui euiw eub eubw ;
#
#USER_LIBRARY = eu ;
#
#EuMain euc : [ FDirName $(SUBDIR) ec.ex ] ;
#EuMain eutest : [ FDirName $(SUBDIR) eutest.ex ] ;
#
#InstallBin bin : euc eutest ;
#
#if $(EUDOC_SOURCE)
#{
#    EuMain eudoc : $(EUDOC_SOURCE) ;
#    InstallBin bin : eudoc ;
#}
#
#if $(CREOLEHTML_SOURCE)
#{
#    EuMain creolehtml : $(CREOLEHTML_SOURCE) ;
#    InstallBin bin : creolehtml ;
#}

