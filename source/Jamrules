#
# Default user library
#
USER_LIBRARY = eu$(SUFLIB) ;

#
# Setup compiler specific flags
#
if $(JAM_TOOLSET) = WATCOM
{
    CCFLAGS = /bt=nt /mf /w0 /zq /j /zp4 /fp5 /fpi87 /5r /otimra /s /I.. /Ipcre
        /dMANAGED_MEM /dEWINDOWS /dEOW /dEWATCOM ;
}

#
# This rule helps debugging as it prints out a variable recursively
#
rule EchoVar
{
    local __i ;
    for __i in $(1)
    {
        echo $(__i) "=" [$($(__i))] ;
    }
}

#
# Generates be_rev.c
#
actions RevGet
{
    eui revget.ex
}

#
# Generate the be_magic.c file
#
rule MagicGet
{
    Depends $(<) : be_execute$(SUFOBJ) ;
    MagicGet1 $(<) : be_execute$(SUFOBJ) ;
}

actions MagicGet1
{
    eui findjmp.ex $(<) $(>) ;
}

#
# EuMain builds an executable from euphoria source
#
rule EuMain
{
    local _s _t ;

    # so 'jam foo' works when it's really foo.exe

    # Add grist to file names
    # Add suffix to exe

    _s = [ FGristFiles $(>) ] ;
    _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

    if $(_t) != $(<)
    {
        Depends $(<) : $(_t) ;
        NotFile $(<) ;
    }

    Depends exe : $(_t) ;
    Depends $(_t) : $(_s) ;

    # Setup the rules that will scan Euphoria source looking
    # for include statements, thus adding them as dependencies
    HDRRULE on $(_s) = HdrRule ;
    HDRSCAN on $(_s) = "^[^-\"\'\/]*include[ ]+([^ ]+.[ex])" ;
    HDRSEARCH on $(_s) = $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;
    HDRGRIST on $(_s) = $(HDRGRIST) ;

    # Add our resulting executable to the clean target
    Clean clean : $(_t) ;

    MakeLocate $(_t) : $(BUILD_DIR) ;

    Depends all : $(<) ;
    Depends $(<) : $(>) ;
    Depends $(<) : $(USER_LIBRARY) ;

    EuMain1 $(<) : $(>) ;
}

actions EuMain1
{
    euc $(EUCFLAGS) -o $(<) -builddir $(BUILD_DIR) -lib $(USER_LIBRARY) $(>)
}
