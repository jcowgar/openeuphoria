== Platform Specific Issues

=== Introduction

OpenEuphoria currently supports Euphoria on many different
//platforms//. More platforms will be added in the future.

**Windows ,,(tm),,** in particular, the 32-bit version of
Windows that is used on Windows 95/98/ME, as well as NT/2000/XP and
later systems.

**Linux**. Linux is based on the UNIX operating
system. It has recently become very popular  on PCs. There are many
distributors of Linux, including Red Hat, Debian, Caldera, etc. Linux
can be obtained on a CD for a very low price. Linux  is an open-source
operating system.

**FreeBSD**. FreeBSD is also based on the UNIX
operating system. It is very popular on  Internet server machines. It's
also open source.

Apple's **OS X**. OS X is also based on the UNIX
operating system. While it is closed source, it is gaining a wide
following due to it's ease of use and power.

**Sun OS**.  Sun OS was developed by and is owned
by SUN Microsystems Inc.  It is also based on UNIX.

**Open BSD**. Open BSD is also a UNIX-like
Operating System and is developed by volunteers.

**Net BSD**. Net BSD is also a UNIX-like
Operating System  and is designed to be easily  portable to other
hardware platforms.

Euphoria source files use various file extensions. The common
extensions are:

| .e | Euphoria include file |
| .ew | Euphoria include file for a Windowed (GUI) application only |
| .ex | Console main program file |
| .exw | Windowed (GUI) main program file |

The Euphoria for Windows installation file contains **eui.exe**. It runs
Euphoria programs on the Windows 32bit platform.

The Euphoria for Linux .tar file contains only **eui**. It runs
Euphoria programs on the Linux platform.

The FreeBSD version of Euphoria is installed by first installing the Linux
version of Euphoria, and then replacing eui, by the version of eui for
FreeBSD.

Sometimes you'll find that the majority of your code will be the
same on all platforms, but some small parts will have to be
written differently for each platform. Use the [[:platform]] built-in function to
tell you which platform you are currently running on. Note that
platform() returns the same value (3) on both Linux and FreeBSD,
since those systems are so similar. OS X returns (4) as it is different enough
to warrant it's own identifier.

=== The WIN32 Platform

With WIN32 you also have access to all of the memory on your machine.
Most library routines work the same way on each platform. Many existing
text mode programs written for MS-DOS can be run using
**eui** without any change. With **eui** you can run programs from the
command line, and display text on a standard
(typically 25 line x 80 column) DOS window. The DOS window is known as the
##//console//## in Windows terminology. Euphoria makes the
transition from DOS32 text mode programming, to WIN32 console programming, trivial.

**You can add calls to WIN32 C functions and later,
if desired, you can create real Windows GUI windows.**

A console window will be created automatically when a WIN32 Euphoria program
first outputs something to the screen or reads from the keyboard.
You will also see a console window when you read standard input or write to
standard output, even when these have been redirected to files. The console
will disappear when your program finishes execution, or via a call to
[[:free_console]].
If there is something on the console that you want your
user to read, you should prompt him and wait for his input before terminating.
To prevent the console from quickly disappearing you might include a statement
such as:

<eucode>
if getc(0) then
end if
</eucode>
which will wait for the user enter something.

If you want to run Euphoria programs without popping up a new console
window use eui.exe otherwise use euiw.exe. eui.exe uses the current
console window.

Under WIN32, long filenames are fully supported for reading and writing and
creating.

==== High-Level WIN32 Programming

Thanks to **David Cuny**, **Derek Parnell**, **Judith Evans**
and many others, there's a package called **Win32Lib** that
you can use to develop Windows GUI applications in Euphoria. It's
remarkably easy to learn and use, and comes with good documentation and
many small example programs. You can download Win32Lib and Judith's IDE
from the [[http://www.RapidEuphoria.com | Euphoria Web site]].
**Andrea Cini** has also developed a similar, somewhat smaller package
called **EuWinGUI**. It's also available from our site.

==== Low-Level WIN32 Programming

To allow access to WIN32 at a lower level, Euphoria
provides a mechanism for calling any C function in any WIN32 API .dll file,
or indeed in any 32-bit Windows .dll file that you create or someone else
creates. There is also a call-back mechanism that lets Windows call your
Euphoria routines. Call-backs are necessary when you create a graphical
user interface.

To make full use of the WIN32 platform, you need documentation on 32-bit
Windows programming, in particular the WIN32 Application Program Interface
(API), including the C structures defined by the API. There is a large
WIN32.HLP file (c) Microsoft that is available with many programming tools
for Windows. There are numerous books available on the
subject of WIN32 programming for {{{C/C++}}}. You can adapt most of what you find
in those books to the world of Euphoria programming for WIN32.
A good book is **//{{{Programming Windows}}} by Charles Petzold//**.

A WIN32 API Windows help file (8 Mb) can be downloaded from
ftp://ftp.borland.com/pub/delphi/techpubs/delphi2/win32.zip, Borland's
Web site.

=== The Unix Platforms

As with WIN32, you can write text on a console, or xterm window,
in multiple colors and at any line or column position.

Just as in WIN32, you can call C routines in shared libraries
and C code can call back to your Euphoria routines.

Euphoria for Unix does not have integrated support for
pixel graphics, but Pete Eberlein has created a
Euphoria interface to **svgalib**.

Easy X windows GUI programming is available using either Irv Mullin's
EuGTK interface to the GTK GUI library, or wxEuphoria developed by
Matt Lewis. wxEuphoria also runs on Windows.

When porting code from Windows to Unix, you'll notice the following differences:

* Some of the numbers assigned to the 16 main colors in graphics.e
are different. If you use the constants defined in graphics.e you won't
have a problem. If you hard-code your color numbers you will see
that blue and red have been switched etc.
* The key codes for special keys such as Home, End, arrow keys
are different, and there are some additional differences when you run
under XTERM.
* The Enter key is code 10 (line-feed) on Linux, where on Windows
it was 13 (carriage-return).
* Linux and FreeBSD use '/' (slash) on file paths. Windows use '\' (backslash).
* Calls to system() and system_exec() that contain Windows commands
will obviously have to be changed to the corresponding Linux or FreeBSD
command. e.g. "DEL" becomes "rm", and "MOVE" becomes "mv".

=== Interfacing with C Code (WIN32, Linux, FreeBSD)

On WIN32 and Unix it's possible to interface Euphoria code with C code. Your Euphoria
program can call C routines and read and write C variables. C routines can even call
("callback") your Euphoria routines. The C code must reside in a WIN32 dynamic link
library (.dll file), a Linux or FreeBSD shared library (.so file) or an OS X shared
library (.dylib file). By interfacing with .dll libraries and shared libraries, you can
access the full programming interface on these systems.

Using the Euphoria to C Translator, you can translate Euphoria routines to C, and compile
them into a shared library file. You can pass Euphoria atoms and sequences to these
compiled Euphoria routines, and receive Euphoria data as a result. Translated/compiled
routines typically run much faster than interpreted routines. For more information, see
the [[:Translator -> "Euphoria to C Translator"]].

==== Calling C Functions

To call a C function in a shared library file you must perform the following steps:
# Open the shared library file that contains the C function by calling [[:open_dll]].
# Define the C function, by calling [[:define_c_func]] or [[:define_c_proc]].
This tells Euphoria the number and type of the arguments as well as the
type of value returned.\\
Euphoria currently supports all C integer and pointer types as
arguments and return values. It also supports floating-point arguments
and return values (C double type). It is currently not possible to
pass C structures by value or receive a structure as a function
result, although you can certainly pass a pointer to a structure
and get a pointer to a structure as a return value. Passing C
structures by value is rarely required for operating system calls.\\
Euphoria also supports all forms of Euphoria data - atoms and
arbitrarily-complex sequences, as arguments to translated/compiled
Euphoria routines.
# Call the C function by calling [[:c_func]] or [[:c_proc]]
<eucode>
include dll.e

atom user32
integer LoadIcon, icon

user32 = open_dll("user32.dll")

-- The name of the routine in user32.dll is "LoadIconA".
-- It takes a pointer and an 32-bit integers as arguments,
-- and it returns a 32-bit integer.
LoadIcon = define_c_func(user32, "LoadIconA", {C_POINTER, C_INT}, C_INT)

icon = c_func(LoadIcon, {NULL, IDI_APPLICATION})
</eucode>

See [[:c_func]], [[:c_proc]], [[:define_c_func]], [[:define_c_proc]], [[:open_dll]]

See ##**demo\win32**## or ##**demo/linux**## for example programs.

On Windows there is more than one C calling convention.
The Windows API routines all use the **{{{__stdcall}}}** convention.
Most C compilers however have **{{{__cdecl}}}** as their default.
{{{__cdecl}}} allows for variable numbers of arguments to be passed.
Euphoria assumes {{{__stdcall}}}, but if you need to call a C routine
that uses {{{__cdecl}}}, you can put a '+' sign at the start of the
routine name in define_c_proc() and define_c_func(). In the
example above, you would have "+LoadIconA", instead of "LoadIconA".

You can examine a ##dll## file by right-clicking on it, and choosing
"QuickView" (if it's on your system). You will see a list of all the C
routines that the ##dll## exports.

To find out which **.**dll file contains a particular WIN32 C function,
run **euphoria\demo\win32\dsearch.exw**

==== Accessing C Variables

You can get the address of a C variable using [[:define_c_var]].
You can then use [[:poke]] and [[:peek]] to access the value of the variable.

==== Accessing C Structures

Many C routines require that you pass pointers to structures. You can
simulate C structures using allocated blocks of memory. The address
returned by [[:allocate]] can be passed as if it were a C pointer.

You can read and write members of C structures using [[:peek]] and [[:poke]], or
[[:peek4u]], [[:peek4s]], and [[:poke4]]. You can allocate space for
structures using [[:allocate]].\\
You must calculate the offset of a member of a C structure. This is usually
easy, because anything in C that needs 4 bytes will be assigned 4
bytes in the structure. Thus C int's, char's, unsigned int's, pointers to
anything, etc. will all take 4 bytes. If the C declaration looks like:

{{{
// Warning C code ahead!

struct example {
    int a;           // offset  0
    char *b;         // offset  4
    char c;          // offset  8
    long d;          // offset 12
};
}}}

To allocate space for "struct example" you would need:
<eucode>
atom p = allocate(16) -- size of "struct example"
</eucode>

The address that you get from [[:allocate]] is always at least 4-byte aligned.
This is useful, since WIN32 structures are supposed to start on a
4-byte boundary. Fields within a C structure that are 4-bytes or more in size
must start on a 4-byte boundary in memory. 2-byte fields must start on a
2-byte boundary. To achieve this you may have to leave small gaps within
the structure. In practice it is not hard to align most structures since
90% of the fields are 4-byte pointers or 4-byte integers.

You can set the fields using something like:
<eucode>
poke4(p + 0, a)
poke4(p + 4, b)
poke4(p + 8, c)
poke4(p +12, d)
</eucode>

You can read a field with something like:
<eucode>
d = peek4(p+12)
</eucode>

; Tip:
: For readability, make up Euphoria constants for the field offsets.
See Example below.

<eucode>
constant RECT_LEFT = 0,
RECT_TOP  = 4,
RECT_RIGHT = 8,
RECT_BOTTOM = 12,
RECT_SIZEOF = 16

atom rect = allocate(RECT_SIZEOF)

poke4(rect + RECT_LEFT,    10)
poke4(rect + RECT_TOP,     20)
poke4(rect + RECT_RIGHT,   90)
poke4(rect + RECT_BOTTOM, 100)

-- pass rect as a pointer to a C structure
-- hWnd is a "handle" to the window
if not c_func(InvalidateRect, {hWnd, rect, 1}) then
    puts(2, "InvalidateRect failed\n")
end if
</eucode>

The Euphoria code that accesses C routines and data structures
may look a bit ugly, but it will typically form just a small
part of your program, especially if you use Win32Lib,
EuWinGUI, or Irv Mullin's X Windows library.
Most of your program will be written in pure Euphoria,
which will give you a big advantage over those forced to code in C.

==== Call-backs to your Euphoria routines

When you create a window, the Windows operating system will need to call your
Euphoria routine.
To set this up, you must get a 32-bit "call-back"
address for your routine and give it to Windows. For example (taken from
**demo\win32\window.exw**):
<eucode>
integer id
atom WndProcAddress

id = routine_id("WndProc")

WndProcAddress = call_back(id)
</eucode>

[[:routine_id]] uniquely identifies a
Euphoria procedure or function by returning an integer value. This
value can be used later to call the routine. You can also use it as an
argument to the [[:call_back]] function.

In the example above, The 32-bit //call-back address//, ##WndProcAddress##,
can be stored in a C structure and passed to Windows via the
~RegisterClass() C API function.\\
**This gives Windows the ability to call the Euphoria routine, ~WndProc(),
whenever the user performs an action on a certain class of window.**
Actions include clicking the mouse, typing a key, resizing the window etc.\\
//See the **window.exw** demo program for the whole story.//

;Note:
: It is possible to get a //call-back address// for
**//any//** Euphoria routine that meets the following conditions:
* the routine must be a function, not a procedure
* it must have from 0 to 9 parameters
* the parameters should all be of type atom (or integer etc.),
not sequence
* the return value should be an integer value up to 32-bits in size

You can create as many call-back addresses as you like, but you should
not call [[:call_back]] for the same Euphoria routine multiple times -
each call-back address that you create requires a small block of memory.

The values that are passed to your Euphoria routine can be any 32-bit
##unsigned## atoms, i.e. non-negative. Your routine could
choose to interpret large positive numbers as negative if that is desirable.
For instance,
if a C routine tried to pass you -1, it would appear as hex FFFFFFFF.
If a value is passed that does not fit the type you have chosen for a
given parameter, a Euphoria type-check error may occur (depending on
[[:type_check]]) \\
No error will occur if you declare all parameters as ##atom##.

Normally, as in the case of ~WndProc() above, Windows initiates these
call-backs to your routines. **It is also
possible for a C routine in any .dll to call one of your Euphoria
routines.** You just have to declare the C routine properly,
and pass it the call-back address.

Here's an example of a WATCOM C routine that takes your call-back address as
its only parameter, and then calls your 3-parameter Euphoria routine:

{{{
/* 1-parameter C routine that you call from Euphoria */
unsigned EXPORT APIENTRY test1(
    LRESULT CALLBACK (*eu_callback)(unsigned a,
    unsigned b,
    unsigned c))
{
    /* Your 3-parameter Euphoria routine is called here
    via eu_callback pointer */
    return (*eu_callback)(111, 222, 333);
}
}}}

The C declaration above declares test1 as an externally-callable C
routine that takes a single parameter. The single parameter is a pointer
to a routine that takes 3 unsigned parameters - i.e. your Euphoria routine.

In WATCOM C, "CALLBACK" is the same as "{{{__stdcall}}}".
This is the calling convention that's used to call WIN32 API routines,
and the C pointer to your Euphoria routine should be declared this way too,
or you'll get an error when your Euphoria routine tries to return to
your .DLL.

If you need your Euphoria routine to be called using the {{{__cdecl}}}
convention, you must code the call to call_back() as:

<eucode>
myroutineaddr = call_back({'+', id})
</eucode>

The plus sign and braces indicate the {{{__cdecl}}} convention. The simple case,
with no braces, is {{{__stdcall}}}.

In the example above, your Euphoria routine will be passed the
three values 111, 222 and 333
as arguments. Your routine will return a value to test1. That value will then
be immediately returned to the caller of test1 (which could be at some
other place in your Euphoria program).

A call-back address can be passed to the Linux or FreeBSD signal()
function to specify a Euphoria routine to handle various signals (e.g. SIGTERM).
It can also be passed to C routines such as qsort(), to specify a Euphoria
comparison function.
