== EuTEST - Unit Testing

<<LEVELTOC depth=3>>

=== Introduction

The testing system gives you the ability to check if the library,
interpreter and translator works properly by use of //unit tests//.  The
unit tests are **EUPHORIA** include files that ##include unittest.e##
at the top, several test-routines for comparison between expected value
and true value and at the end of the program a call to
##test_report()##.  There are error control files for when we expect
the interpreter to fail but we want it to fail with a particular error
message.

=== The eutest Program

==== Synopsis for running the tests

{{{
stable-interpreter-path [-D REC] eutest.ex
    [-verbose] [-log] [-i include path] [-cc wat|gcc] [-exe interpreter]
    [-ec translator] [-lib binary library path]
    [optional list of unit test files]
}}}

==== Synopsis for creating report from the log

{{{
stable-interpreter-path eutest.ex -process-log [-html]
}}}

==== General behavior

For your //stable-interpreter-path// please use a stable interpreter,
to run eutest.ex.  You should use a alpha or beta release copy as your
'//stable-interpreter-path//', then you can use -exe to specify your
'//test interpreter path//' which could be your build of an SVN version
or your own modified copy.  If you want to test translation as well, you
can specify it in a similar way with -ec.  Developers, *please* do not
modify eutest.ex to use features not available in the last two alpha
releases.  If you don't specify unit tests on the command line eutest
will scan the directory for unit test files using the pattern
##t_*.e##.  If you specify a pattern it will interpret the pattern as
some shells do not do this for programs.

==== Options detail

* -D REC: Is for creating control files, use only when on tests that
work already on an interpreter that correctly works or correctly
*fails* with them.  This option must come before the eutest.ex program
itself in the command line and is the option with that requirement.
* -log: Is for creating a log file for later processing
* -verbose: Is for eutest.ex to give you detail of what it is doing
* -i: is for specify the include path which will be passed to both the
  interpreter and the translator when interpreting and translating the
  test.
* -cc: is for specifying the compiler.  This can be any one of -wat,
  djg, or lcc.  Each of these represent the kind of compiler we will
  request the translator to use.
* -process-log: Is for processing a log created by a previous
invocation of eutest.ex output is sent to standard output as a report
of how the tests went.  By default this is in ascii format.  Use -html
to make it HTML format.
* -html: Is for making the report creation to be in HTML format

=== The Unit Test Files

Unit test files must match a pattern ##t_*.e##.  If the unit test file
matches ##t_c_*.e## the test program will expect the program to fail,
if there is an error control file in a directory with its same name and
'd' extension it will also expect it to fail according to the control
file's contents.  Found in the said directory.

==== A trivial example

The following is a minimal unit test file:
{{{
include std/unittest.e

test_report()
}}}

Please see "Unit Test Framework", currently 13.5, for information on how to
construct these files.


==== You can generate these files by

=== The Error Control Files

There are times when we expect something to fail.  We want good
EUPHORIA code to do the correct thing and there is a correct thing to
do also for *bad* code.  The interpreter must return with an error message
of why it failed and the error must be correct and it must get written to ex.err.
We must thus check the ex.err file to see if it has
the correct error message.

If the unit test is ##t_foo.e## then the location for its control file
can be in the following locations:

* ##t_foo.d/interpreter///OSNAME///control.err##
* ##t_foo.d///OSNAME///control.err##
* ##t_foo.d/control.err##

The //OSNAME// is the name of the operating system.  Which is either
UNIX or Win32.

Now, if ##t_foo.d/Win32/control.err## exists, then the testing program
eutest.ex expects t_foo.e to fail when run with the WIN32 interpreter.
However, this is not necessarily true for other platforms.  In WIN32,
eutest runs it, watches it fail, then compares the ex.err file to
##t_foo.d/Win32/control.err##.  If they ex.err is different from
control.err an error message is written to the log.  Now on, say NetBSD,
t_file.e is tested with the expectation it will return 0 and the tests
will all pass unless ##t_foo.d/UNIX/control.err## or ##t_foo.d/control.err## also exist.
Thus you can have different expectations for differing platforms.
Some feature that is not possible to implement under WIN32 can be put into a unit test and the
resulting ex.err file can be put into a control file for WIN32.
This means we do not need to have all of these errors that we expect to get
drawing our attention away from errors that need our attention.
On the other hand, if an unexpected error message not like ##t_foo.d/Win32/control.err##
gets generated in the Windows case then eutest will tell us that.

How do we construct these control files?  You don't really need to, you
can take an ex.err file that results from running a stable interpreter
on a test and rename it and move it to the appropriate place.
