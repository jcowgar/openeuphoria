<!-- GENERATED BY A EUPHORIA PROGRAM. DO NOT EDIT! -->


<html>
<head><title>Platform-Specific Issues for Euphoria</title>
<style type="text/css">
<!--
body        {background-color: "#FFFFFF";}
a           {text-decoration: none;}
a:link      {color: "#0033BB"; text-decoration: underline;}
a:visited   {color: "#006699"; text-decoration: underline;}
a:active    {color: red; text-decoration: underline;}
a:hover     {color: red; text-decoration: underline;}
a.blue    {text-decoration: none;}
a.blue:link      {color: "#5500FF"; text-decoration: underline;}
a.blue:visited   {color: "#5500FF"; text-decoration: underline;}
a.blue:active    {color: red; text-decoration: underline;}
a.blue:hover     {color: red; text-decoration: underline;}
a.brown      {text-decoration: none;}
a.brown:link      {color: "#993333"; text-decoration: underline;}
a.brown:visited   {color: "#993333"; text-decoration: underline;}
a.brown:active    {color: red; text-decoration: underline;}
a.brown:hover     {color: red; text-decoration: underline;}
-->
</style>

</head>
<body bgcolor="#FFFFFF" link="#0033BB" vlink="#006699">
<table width=90% border=0><tr><td>

<center><font face="Arial, Helvetica" color="#FF0099" size=+2>
<br>
 Platform-Specific Issues for Euphoria
</font></center>
<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

1. Introduction

</font>
<p>
 Rapid Deployment Software currently supports Euphoria on four different
 <font color="#993333"><b><i>platforms</i></b></font>. More 
 platforms will be added in the future. 
 
<p>
 The first platform is called
 <font color="#CC3366"><b>DOS32</b></font>, 
 since it depends on the DOS operating system, but with the CPU operating 
 in 32-bit (protected) mode. 
 
<p>
 The second platform is called <font color="#CC3366"><b>WIN32</b></font>,
 since the underlying operating system is Microsoft Windows, in particular,
 the 32-bit version of Windows that is used on Windows 95/98/ME, as well as
 NT/2000/XP and later systems. 
 
<p>
 The third platform is <font color="#CC3366"><b>Linux</b></font>. Linux is
 based on the UNIX operating system. It has recently become very popular 
 on PCs. There are many distributors of Linux, including Red Hat, Debian,
 Caldera, etc. Linux can be obtained on a CD for a very low price. Linux 
 is an open-source operating system.

<p>
 The fourth platform is <font color="#CC3366"><b>FreeBSD</b></font>. FreeBSD 
 is also based on the UNIX operating system. It is very popular on 
 Internet server machines. It's also open source.

<p>
 Users who have purchased the Euphoria source code have ported Euphoria
 to other platforms, such as HP Unix and Sun Unix.
 
<p> 
 The Euphoria for DOS32+WIN32 installation file contains two 
 <b>.exe</b> files. 
 The first is called <font color="#993333"><b>ex.exe</b></font>.
 It runs Euphoria programs on the DOS32 platform. The second is
 <font color="#993333"><b>exw.exe</b></font>.
 It runs Euphoria programs on the WIN32 platform. 
 Euphoria programs that are
 meant to be run on the WIN32 platform have a <b>.exw</b> file type,
 while programs that are meant to be run on the DOS32 platform have a
 <b>.ex</b> file type.
 <p>
 The Euphoria for Linux .tar file contains only 
 <font color="#993333"><b>exu</b></font>. It runs
 Euphoria programs on the Linux platform.
 Euphoria programs intended for Linux or FreeBSD have a <b>.exu</b> file type. 
 
 <p>
 The FreeBSD version of Euphoria is installed by first installing the Linux
 version of Euphoria, and then replacing exu, by the version of exu 
 for FreeBSD.
 
 <p>
 Many Euphoria programs can be run on two, three, or all four platforms 
 without change. The file type should indicate the preferred platform 
 for the program.
 Any Euphoria interpreter can try to run any Euphoria file, but you 
 might have to specify the full name of the file, including the type,
 since each interpreter looks for it's own preferred file type 
 (.ex, .exw or .exu).
 
 <p>
 Sometimes you'll find that the majority of your code will be the 
 same on all platforms, but some small parts will have to be 
 written differently for each platform. Use the
 <a href=lib_p_r.htm#platform>platform()</a> built-in function to 
 tell you which platform you are currently running on. Note that
 platform() returns the same value (3) on both Linux and FreeBSD,
 since those systems are so similar.
 
 
<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

2. The DOS32 Platform

</font>
<p>
 If you are new to programming, you might want to start with
 <font color="#993333"><b>ex.exe</b></font> on the
 DOS32 platform. You should try to understand the 
 essential core of Euphoria, before you leap into Windows GUI programming.
 All versions of Windows (even XP), let you open a Command Prompt
 text window, and run DOS programs.
 
<p> 
 <font color="#006633"><b>Euphoria programs run in 32-bit (protected) mode and
 have access to all of the megabytes of memory on the machine.</b></font>
 Many programming languages for DOS limit 
 you to 16-bit <b>real</b> mode. This makes it impossible to
 access more than 640K 
 of memory at one time. Your machine might have 256Mb of memory, but your 
 program will run out of memory after using just 640K. QBasic is even worse. It 
 limits you to just 160K.
 
 <p>
 DOS32 programs can flip the screen into either
 <font color="#CC3366">text mode</font> or 
 <font color="#CC3366">pixel graphics mode</font>, and Euphoria provides
 you with library routines for both modes.
 There is rarely any need to call DOS directly, but you can do 
 this using the <a href="lib_c_d.htm#dos_interrupt">dos_interrupt()</a>
 routine. You can also <a href="lib_p_r.htm#peek">peek</a> and
 <a href="lib_p_r.htm#poke">poke</a> into 
 special memory locations to achieve high-speed graphics and get access 
 to low-level details of the system.
 
 <p>
 Under <font color="#CC3366"><b>DOS32 for Windows 95 and later systems</b></font>,
 Euphoria files can have long filenames, and 
 programs can open long filename files for reading and writing, but not for 
 creating a new file.

 <p>
 <a name=swapfile></a>
 Under <font color="#CC3366"><b>pure DOS, outside of Windows</b></font>,
 there is no system <a href="refman_1.htm#32">swap file</a> so the
 DOS-extender built in to <font color="#993333"><b>ex.exe</b></font> will
 create one for possible use by your program. 
 This file is created when your Euphoria program starts up under DOS,
 and is deleted when your program terminates. It starts as a 0-byte file and 
 grows only if actual swapping is needed. It is created in the directory on 
 your hard disk pointed to by the TEMP or TMP environment variable. If neither
 of these variables have been set, it is created in the directory containing 
 either <font color="#993333"><b>ex.exe</b></font> or your
 <font color="#993333"><b>bound</b></font> Euphoria <b>.exe</b> file.
 You can force it to be created in a particular directory by setting the
 CAUSEWAY environment variable as follows:
 	
<pre><font color="#330033">        SET CAUSEWAY=SWAP:path</font>
</pre>
 
 where &nbsp; <b>path</b> &nbsp; is the full path to the directory. You can
 prevent the creation of a DOS swap file with:

<pre><font color="#330033">        SET CAUSEWAY=NOVM</font>
</pre>

<p>
 When disk swapping activity occurs, your program will run correctly but will 
 slow down. A better approach might be to free up more extended memory by 
 cutting back on SMARTDRV and other programs that reserve large amounts of 
 extended memory for themselves.

<p>
 When your free disk space is less than the amount of RAM in your machine,
 no swap file will be created.

<p>
<a name=win32plat></a>
<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

3. The WIN32 Platform

</font>
<p>
 Euphoria for WIN32 (<font color="#993333"><b>exw.exe</b></font>) has a
 lot in common with Euphoria for DOS32. 
 With WIN32 you also have access to all of the memory on your machine.
 Most library routines work the same way on each platform. Many existing 
 DOS32 <font color="#CC3366">text mode</font> programs can be run using
 <font color="#993333"><b>exw</b></font> without any change. With
 <font color="#993333"><b>exw</b></font> you can run programs from the
 command line, and display text on a standard 
 (typically 25 line x 80 column) DOS window. The DOS window is known as the
 <b><i>console</i></b> in Windows terminology. Euphoria makes the
 transition from DOS32 <font color="#CC3366">text mode</font> programming,
 to WIN32 console programming, trivial.
 <font color="#006633"><b>You can add calls to WIN32 C functions and later,
 if desired, you can create real Windows GUI windows.</b></font>
 
 <p>
 A console window will be created automatically when a WIN32 Euphoria program 
 first outputs something to the screen or reads from the keyboard. 
 You will also see a console window when you read standard input or write to 
 standard output, even when these have been redirected to files. The console
 will disappear when your program finishes execution, or via a call to 
 <a href="lib_e_g.htm#free_console">free_console()</a>.
 If there is something on the console that you want your
 user to read, you should prompt him and wait for his input before terminating.
 To prevent the console from quickly disappearing you might include a statement
 such as:

<pre><font color="#0000FF">        if </font><font color="#FF00FF">getc</font><font color="#330033">(0) </font><font color="#0000FF">then</font>
<font color="#0000FF">        end if</font>
</pre>
 which will wait for the user enter something.

<p>
If you want to run Euphoria programs without popping up a new console
window use exwc.exe. It uses the current
console window, just like a DOS program would when using ex.exe.


<p>
 Under WIN32, long filenames are fully supported for reading and writing and
 creating.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

3.1 High-Level WIN32 Programming

</font>
<p>
 Thanks to <b>David Cuny</b>, <b>Derek Parnell</b>, <b>Judith Evans</b> 
 and many others, there's a package called <b>Win32Lib</b> that
 you can use to develop Windows GUI applications in Euphoria. It's
 remarkably easy to learn and use, and comes with good documentation and
 many small example programs. You can download Win32Lib and Judith's IDE 
 from the Euphoria <a href="http://www.RapidEuphoria.com">Web site</a>.
 Recently, <b>Andrea Cini</b> has developed a similar, somewhat smaller package
 called <b>EuWinGUI</b>. It's also available from our site.
 
 
<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

3.2 Low-Level WIN32 Programming

</font>
<p>
 <font color="#006633"><b>To allow access to WIN32 at a lower level, Euphoria
 provides a mechanism for calling any C function in any WIN32 API .dll file,
 or indeed in any 32-bit Windows .dll file that you create or someone else
 creates. There is also a call-back mechanism that lets Windows call your
 Euphoria routines. Call-backs are necessary when you create a graphical
 user interface.</b></font>
 
<p>
 To make full use of the WIN32 platform, you need documentation on 32-bit 
 Windows programming, in particular the WIN32 Application Program Interface 
 (API), including the C structures defined by the API. There is a large 
 WIN32.HLP file (c) Microsoft that is available with many programming tools
 for Windows. There are numerous books available on the
 subject of WIN32 programming for C/C++. You can adapt most of what you find
 in those books to the world of Euphoria programming for WIN32.
 A good book is:<p>
 
<center>
 <i>Programming Windows</i><br>
 by Charles Petzold<br>
 Microsoft Press<br>
</center>
 
<p>
 A WIN32 API Windows help file (8 Mb) can be downloaded from Borland's 
 Web site:<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <a href="ftp://ftp.borland.com/pub/delphi/techpubs/delphi2/win32.zip">
 ftp://ftp.borland.com/pub/delphi/techpubs/delphi2/win32.zip</a>

<p>
 See also the Euphoria
 <a href="http://www.RapidEuphoria.com/doc.htm">Archive Web
 page - "documentation"</a>.
 
<p>
<a name=linuxplat></a>
<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

4. The Linux and FreeBSD Platforms

</font>
<p>
Euphoria for Linux, and Euphoria for FreeBSD share certain features 
with Euphoria for DOS32,
and share other features with Euphoria for WIN32. 
<p>
As with WIN32 and DOS32, you can write text on a console, or xterm window, 
in multiple colors and at any line or column position. 
<p>
Just as in WIN32, you can call C routines in shared libraries 
and C code can call back to your Euphoria routines.
<p>
Euphoria for Linux and FreeBSD do not have integrated support for 
pixel graphics like DOS32, but Pete Eberlein has created a 
Euphoria interface to <b>svgalib</b>. 
<p>
Easy X windows GUI programming is available using either Irv Mullin's 
EuGTK interface to the GTK GUI library, or wxEuphoria developed by
Matt Lewis. wxEuphoria also runs on Windows.
<p>
When porting code from DOS or Windows to Linux or FreeBSD, 
you'll notice the following differences:
<ul>
<p>
<li>Some of the numbers assigned to the 16 main colors in graphics.e 
are different. If you use the constants defined in graphics.e you won't
have a problem. If you hard-code your color numbers you will see
that blue and red have been switched etc.
<p>
<li>The key codes for special keys such as Home, End, arrow keys
are different, and there are some additional differences when you run
under XTERM.
<p>
<li>The Enter key is code 10 (line-feed) on Linux, where on DOS/Windows
it was 13 (carriage-return).
<p>
<li>Linux and FreeBSD use '/' (slash) on file paths. 
DOS/Windows uses '\\' (backslash).
<p>
<li>Highly specialized things such as dos_interrupt() obviously won't
work on Linux or FreeBSD.
<p>
<li>Calls to system() and system_exec() that contain DOS commands
will obviously have to be changed to the corresponding Linux or FreeBSD 
command. e.g. "DEL" becomes "rm", and "MOVE" becomes "mv".
</ul>

 
<p>
<a name=call_cfunc></a>
<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>
5. Interfacing with C Code (WIN32, Linux, FreeBSD)
</font>
<p>
On WIN32, Linux and FreeBSD it's possible to interface Euphoria code
with C code. Your Euphoria program can call C routines and 
read and write C variables.
C routines can even call ("callback") your Euphoria routines. 
The C code must reside in a WIN32 dynamic link library (.dll file), 
or a Linux or FreeBSD shared library (.so file).
By interfacing with .dll's and shared libraries, you can 
access the full programming interface on these systems.

<p>
Using the Euphoria to C Translator, you can translate
Euphoria routines to C, and compile them into a .dll or .so file.
You can pass Euphoria atoms and sequences to these
compiled Euphoria routines, and receive Euphoria data as 
a result. Translated/compiled routines typically
run much faster than interpreted routines. For more information 
see <a href=e2c.htm>the Translator</a>.

<p>
 
<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

5.1 Calling C Functions

</font>
<p>
 To call a C function in a <b>.</b>dll or <b>.</b>so file
 you must perform the following steps:

<p>
<table border=0 cellspacing=2 cellpadding=2>

 <tr><td valign=top><b>1.</b></td>
<td>Open the <b>.</b>dll or <b>.</b>so file that contains the C function by
     calling <a href="lib_h_o.htm#open_dll">open_dll()</a> contained in
     <font color="#5500FF"><b>euphoria\include\dll.e</b></font>.
</td></tr>


<tr><td valign=top><b>2.</b></td>
<td>Define the C function, by calling
      <a href="lib_c_d.htm#define_c_func">define_c_func()</a> or
      <a href="lib_c_d.htm#define_c_proc">define_c_proc()</a> in
      <font color="#5500FF"><b>dll.e</b></font>. This tells Euphoria the
      number and type of the arguments as well as the type of value returned. 
      <p>
      Euphoria currently supports all C integer and pointer types as 
      arguments and return values. It also supports floating-point arguments 
      and return values (C double type). It is currently not possible to 
      pass C structures by value or receive a structure as a function 
      result, although you can certainly pass a pointer to a structure
      and get a pointer to a structure as a return value. Passing C
      structures by value is rarely required for operating system calls.
      
      <p>
      Euphoria also supports all forms of Euphoria data - atoms and
      arbitrarily-complex sequences, as arguments to translated/compiled 
      Euphoria routines.
</td></tr>


<tr><td valign=top><b>3.</b></td>
<td>Call the C function by calling
      <a href="lib_c_d.htm#c_func">c_func()</a> or
      <a href="lib_c_d.htm#c_proc">c_proc()</a>.
</td></tr>


</table>
 
<p>
<table border=0 cellspacing=2 cellpadding=2>

<tr><td valign=top><b>Example:</b></td>
<td>
</td></tr>

<tr><td></td><td>
<pre><font color="#0000FF">include </font><font color="#330033">dll.e</font>
<font color="#330033"></font>
<font color="#FF00FF">atom </font><font color="#330033">user32</font>
<font color="#FF00FF">integer </font><font color="#330033">LoadIcon, icon</font>
<font color="#330033"></font>
<font color="#330033">user32 = open_dll(</font><font color="#00A033">"user32.dll"</font><font color="#330033">)</font>
<font color="#330033"></font>
<font color="#FF0055">-- The name of the routine in user32.dll is "LoadIconA".</font>
<font color="#FF0055">-- It takes a pointer and an int as arguments, </font>
<font color="#FF0055">-- and it returns an int.</font>
<font color="#330033">LoadIcon = define_c_func(user32, </font><font color="#00A033">"LoadIconA"</font><font color="#330033">,</font>
<font color="#330033">                         {C_POINTER, C_INT}, C_INT)</font>
<font color="#330033"></font>
<font color="#330033">icon = </font><font color="#FF00FF">c_func</font><font color="#330033">(LoadIcon, </font><font color="#993333">{</font><font color="#330033">NULL, IDI_APPLICATION</font><font color="#993333">}</font><font color="#330033">)</font>
</pre></td></tr>


</table>
 
<p> 
 See <a class="blue" href="library.htm#call_c_func"><b>library.doc - Calling C Functions</b>
 </a>for descriptions of c_func(), c_proc(), define_c_func(), 
 define_c_proc(), open_dll() etc.
 See 
 <font color="#5500FF"><b>demo\win32</b></font> or
 <font color="#5500FF"><b>demo\linux</b></font> 
 for example programs.

<p>
On Windows there is more than one C calling convention.
The Windows API routines all use the <b>__stdcall</b> convention.
Most C compilers however have <b>__cdecl</b> as their default.
__cdecl allows for variable numbers of arguments to be passed.
Euphoria assumes __stdcall, but if you need to call a C routine
that uses __cdecl, you can put a '+' sign at the start of the
routine name in define_c_proc() and define_c_func(). In the
example above, you would have "+LoadIconA", instead of "LoadIconA".


<p> 
 You can examine a <b>.</b>dll file by right-clicking on it, and choosing
 "QuickView" (if it's on your system). You will see a list of all the C
 routines that the <b>.</b>dll exports.

<p>
 To find out which <b>.</b>dll file contains a particular WIN32 C function,
 run <font color="#5500FF"><b>euphoria\demo\win32\dsearch.exw</b></font>.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

5.2 Accessing C Variables

</font>
<p>
You can get the address of a C variable using 
<a href="lib_c_d.htm#define_c_var">define_c_var()</a>.
You can then use poke() and peek() to access the value of the variable.

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<p>
<br>


5.3 Accessing C Structures

</font>
<p>
 Many C routines require that you pass pointers to structures. You can
 simulate C structures using allocated blocks of memory. The address
 returned by <a href="lib_a_b.htm#allocate">allocate()</a> can be passed
 as if it were a C pointer.
<p>
 You can read and write members of C structures using peek() and poke(), or
 <a href="lib_p_r.htm#peek4u">peek4u()</a>,
 <a href="lib_p_r.htm#peek4s">peek4s()</a>, and
 <a href="lib_p_r.htm#poke4">poke4()</a>. You can allocate space for
 structures using <a href="lib_a_b.htm#allocate">allocate()</a>.
 You must calculate the offset of a member of a C structure. This is usually
 easy, because anything in C that needs 4 bytes will be assigned 4 
 bytes in the structure. Thus C int's, char's, unsigned int's, pointers to 
 anything, etc. will all take 4 bytes. If the C declaration looks like:
<pre>
        // Warning C code ahead!

        struct example {
            int a;           // offset  0
            char *b;         // offset  4
            char c;          // offset  8
            long d;          // offset 12
        };
</pre>

<p>
 To allocate space for "struct example" you would need:
<pre><font color="#FF00FF">        atom </font><font color="#330033">p</font>
<font color="#330033"></font>
<font color="#330033">        p = allocate(16) </font><font color="#FF0055">-- size of "struct example"</font>
</pre>
 
<p>
 The address that you get from allocate() is always at least 4-byte aligned.
 This is useful, since WIN32 structures are supposed to start on a 
 4-byte boundary. Fields within a C structure that are 4-bytes or more in size 
 must start on a 4-byte boundary in memory. 2-byte fields must start on a 
 2-byte boundary. To achieve this you may have to leave small gaps within
 the structure. In practice it is not hard to align most structures since
 90% of the fields are 4-byte pointers or 4-byte integers.

<p>
 You can set the fields using something like:
<pre><font color="#FF00FF">        poke4</font><font color="#330033">(p + 0, a)</font>
<font color="#FF00FF">        poke4</font><font color="#330033">(p + 4, b)</font>
<font color="#FF00FF">        poke4</font><font color="#330033">(p + 8, c)</font>
<font color="#FF00FF">        poke4</font><font color="#330033">(p +12, d)</font>
</pre>

 You can read a field with something like:
<pre><font color="#330033">        d = peek4(p+12)</font>
</pre>

<dl>
<dt>
 <b><font color="#006633">Tip:</font></b>
<dd>
 For readability, make up Euphoria constants for the field offsets.
 See Example below.

</dl>

<p>
<table border=0 cellspacing=2 cellpadding=2>

<tr><td valign=top><b>Example:</b></td>
<td>
</td></tr>

<tr><td></td><td>
<pre><font color="#0000FF">constant </font><font color="#330033">RECT_LEFT = 0,</font>
<font color="#330033">         RECT_TOP  = 4,</font>
<font color="#330033">         RECT_RIGHT = 8,</font>
<font color="#330033">         RECT_BOTTOM = 12</font>
<font color="#330033">         </font>
<font color="#FF00FF">atom </font><font color="#330033">rect</font>
<font color="#330033">rect = allocate(16)</font>
<font color="#330033"></font>
<font color="#FF00FF">poke4</font><font color="#330033">(rect + RECT_LEFT,    10)</font>
<font color="#FF00FF">poke4</font><font color="#330033">(rect + RECT_TOP,     20)</font>
<font color="#FF00FF">poke4</font><font color="#330033">(rect + RECT_RIGHT,   90)</font>
<font color="#FF00FF">poke4</font><font color="#330033">(rect + RECT_BOTTOM, 100)</font>
<font color="#330033">     </font>
<font color="#FF0055">-- pass rect as a pointer to a C structure</font>
<font color="#FF0055">-- hWnd is a "handle" to the window</font>
<font color="#0000FF">if not </font><font color="#FF00FF">c_func</font><font color="#330033">(InvalidateRect, </font><font color="#993333">{</font><font color="#330033">hWnd, rect, 1</font><font color="#993333">}</font><font color="#330033">) </font><font color="#0000FF">then</font>
<font color="#FF00FF">    puts</font><font color="#330033">(2, </font><font color="#00A033">"InvalidateRect failed\n"</font><font color="#330033">)</font>
<font color="#0000FF">end if</font>
</pre></td></tr>


</table>

The Euphoria code that accesses C routines and data structures
may look a bit ugly, but it will typically form just a small
part of your program, especially if you use Win32Lib, 
EuWinGUI, or Irv Mullin's X Windows library. 
Most of your program will be written in pure Euphoria,
which will give you a big advantage over those forced to code in C.
<p>

<a name=callback></a>
<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

5.4 Call-backs to your Euphoria routines

</font>
<p>
 When you create a window, the Windows operating system will need to call your 
 Euphoria routine. This is a strange concept for DOS programmers who are used
 to calling operating system routines, but are not used to having the operating
 system call <font color="#CC0099"><b><i>their</i></b></font> routine.
 To set this up, you must get a 32-bit "call-back" 
 address for your routine and give it to Windows. For example (taken from 
 <font color="#5500FF"><b>demo\win32\window.exw</b></font>):
<pre><font color="#FF00FF">        integer </font><font color="#330033">id</font>
<font color="#FF00FF">        atom </font><font color="#330033">WndProcAddress</font>
<font color="#330033">        </font>
<font color="#330033">        id = </font><font color="#FF00FF">routine_id</font><font color="#330033">(</font><font color="#00A033">"WndProc"</font><font color="#330033">) </font>
<font color="#330033"></font>
<font color="#330033">        WndProcAddress = call_back(id)</font>
</pre>

 <a href="lib_p_r.htm#routine_id">routine_id()</a> uniquely identifies a
 Euphoria procedure or function by returning a small integer value. This
 value can be used later to call the routine. You can also use it as an
 argument to the <a href="lib_c_d.htm#call_back">call_back()</a>
 function.

<p>
 In the example above, The 32-bit <i>call-back address</i>, WndProcAddress, 
 can be stored in a C structure and passed to Windows via the
 RegisterClass() C API function.
 <font color="#006633"><b>This gives Windows the ability to 
 call the Euphoria routine, WndProc(), whenever the user performs an action on 
 a certain class of window.</b></font> Actions include clicking the mouse,
 typing a key, resizing the window etc.</i> See the
 <font color="#5500FF"><b>window.exw</b></font> demo program for the whole 
 story. 
 
<dl>
<dt>
 <b><font color="#006633">Note:</font></b>
<dd>
 It is possible to get a <i>call-back address</i> for
 <font color="#CC0099"><b><i>any</i></b></font> Euphoria
 routine that meets the following conditions:

<ul>
<li>
 the routine must be a function, not a procedure
<li>
 it must have from 0 to 9 parameters
<li>
 the parameters should all be of type atom (or integer etc.),
 not sequence
<li>
 the return value should be an integer value up to 32-bits in size
</ul>
</dl>

 You can create as many call-back addresses as you like, but you should
 not call <a href="lib_c_d.htm#call_back">call_back()</a> for the same
 Euphoria routine multiple times - each call-back address that
 you create requires a small block of memory.

<p>
 The values that are passed to your Euphoria routine can be any 32-bit
 <b>unsigned</b> atoms, i.e. non-negative. Your routine could
 choose to interpret large positive numbers as negative if that is desirable.
 For instance,
 if a C routine tried to pass you -1, it would appear as hex FFFFFFFF.
 If a value is passed that does not fit the type you have chosen for a 
 given parameter, a Euphoria type-check error may occur (depending on 
 <a href="refman_2.htm#62">
 <b><font color="#993333">with/without type_check</font></b></a> etc.) 
 No error will occur if you declare all
 parameters as <font color="#993333"><b>atom</b></font>.

<p>
 Normally, as in the case of WndProc() above, Windows initiates these
 call-backs to your routines. <font color="#006633"><b>It is also
 possible for a C routine in any .dll to call one of your Euphoria
 routines.</b></font> You just have to declare the C routine properly,
 and pass it the call-back address. 
 
<p>
 Here's an example of a WATCOM C routine that takes your call-back address as 
 its only parameter, and then calls your 3-parameter Euphoria routine:

<pre>
        /* 1-parameter C routine that you call from Euphoria */
        unsigned EXPORT APIENTRY test1(
                 LRESULT CALLBACK (*eu_callback)(unsigned a,
                                                 unsigned b,
                                                 unsigned c))
        {
            /* Your 3-parameter Euphoria routine is called here 
               via eu_callback pointer */
            return (*eu_callback)(111, 222, 333); 
        }
</pre>

 The C declaration above declares test1 as an externally-callable C 
 routine that takes a single parameter. The single parameter is a pointer 
 to a routine that takes 3 unsigned parameters - i.e. your Euphoria routine.
 
<p>
 In WATCOM C, "CALLBACK" is the same as "__stdcall".
 This is the calling convention that's used to call WIN32 API routines,
 and the C pointer to your Euphoria routine should be declared this way too,
 or you'll get an error when your Euphoria routine tries to return to 
 your .DLL.
 
 <p>
 If you need your Euphoria routine to be called using the __cdecl
 convention, you must code the call to call_back() as:
 
<pre><font color="#330033">        myroutineaddr = call_back(</font><font color="#993333">{</font><font color="#00A033">'+'</font><font color="#330033">, id</font><font color="#993333">}</font><font color="#330033">)</font>
</pre>

The plus sign and braces indicate the __cdecl convention. The simple case,
with no braces, is __stdcall.

<p>
 In the example above, your Euphoria routine will be passed the 
 three values 111, 222 and 333 
 as arguments. Your routine will return a value to test1. That value will then 
 be immediately returned to the caller of test1 (which could be at some 
 other place in your Euphoria program).

<p> A call-back address can be passed to the Linux or FreeBSD signal()
function to specify a Euphoria routine to handle various signals (e.g. SIGTERM).
It can also be passed to C routines such as qsort(), to specify a Euphoria
comparison function.

<p>&nbsp;

</td></tr></table>

</body>
</html>
 
