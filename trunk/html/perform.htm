<!-- GENERATED BY A EUPHORIA PROGRAM. DO NOT EDIT! -->


<html>
<head><title>Euphoria Performance Tips</title>
<style type="text/css">
<!--
body        {background-color: "#FFFFFF";}
a           {text-decoration: none;}
a:link      {color: "#0033BB"; text-decoration: underline;}
a:visited   {color: "#006699"; text-decoration: underline;}
a:active    {color: red; text-decoration: underline;}
a:hover     {color: red; text-decoration: underline;}
a.blue    {text-decoration: none;}
a.blue:link      {color: "#5500FF"; text-decoration: underline;}
a.blue:visited   {color: "#5500FF"; text-decoration: underline;}
a.blue:active    {color: red; text-decoration: underline;}
a.blue:hover     {color: red; text-decoration: underline;}
a.brown      {text-decoration: none;}
a.brown:link      {color: "#993333"; text-decoration: underline;}
a.brown:visited   {color: "#993333"; text-decoration: underline;}
a.brown:active    {color: red; text-decoration: underline;}
a.brown:hover     {color: red; text-decoration: underline;}
-->
</style>

</head>
<body bgcolor="#FFFFFF" link="#0033BB" vlink="#006699">
<table width=90% border=0><tr><td>

<center><font face="Arial, Helvetica" color="#FF0099" size=+2>
<br>
 Euphoria Performance Tips
</font></center>
<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

General Tips

</font>
<ul>
<li>
 If your program is fast enough, forget about speeding it up.
 Just make it simple and readable.
<p>
<li>
 If your program is way too slow, the tips below will probably not solve 
 your problem. You should find a better overall algorithm.
<p>
<li>
 
 The easiest way to gain a bit of speed is to turn off run-time 
 type-checking. Insert the line:

<pre><font color="#0000FF">           without </font><font color="#330033">type_check</font>
</pre>
 at the top of your main <b>.ex</b> file, ahead of any include statements.
 You'll typically gain between 0 and 20 percent depending on the
 types you have defined, and the files that you are including.
 Most of the standard include files do some user-defined type-checking.
 A program that is completely without user-defined type-checking
 might still be speeded up slightly.
 <p>
 Also, be <font color="#CC0099"><b><i>sure</i></b></font> to remove,
 or comment-out, any
<pre><font color="#0000FF">           with </font><font color="#FF00FF">trace</font>
<font color="#0000FF">           with </font><font color="#FF00FF">profile</font>
<font color="#0000FF">           with </font><font color="#330033">profile_time</font>
</pre>
 statements. <font color="#993333"><b>with trace</b></font> (even without
 any calls to <font color="#006699">trace()</font>), and
 <font color="#993333"><b>with profile</b></font> can easily slow you down
 by 10% or more. <font color="#993333"><b>with profile_time</b></font>
 might slow you down by 1%. Each of these options will consume extra
 memory as well.
<p>
<li>
 Calculations using integer values are faster than calculations using
 floating-point numbers
<p>
<li>
 Declare variables as integer rather than atom where possible,
 and as sequence rather than object where possible. This usually gains
 you a few percent in speed.
<p>
<li>
 In an expression involving floating-point calculations it's usually faster
 to write constant numbers in floating point form, e.g. when x has a
 floating-point value, say, x = 9.9<br><br>
 change:
<pre><font color="#330033">           x = x * 5</font>
</pre>
 to:
<pre><font color="#330033">           x = x * 5.0</font>
</pre>
 This saves the interpreter from having to convert integer 5 to
 floating-point 5.0 each time.
<p>
<li>
 Euphoria does <b><i>short-circuit</i></b> evaluation of
 <font color="#993333"><b>if</b></font>,
 <font color="#993333"><b>elsif</b></font>, and
 <font color="#993333"><b>while</b></font> conditions involving
 <font color="#993333"><b>and</b></font> and
 <font color="#993333"><b>or</b></font>. Euphoria will stop evaluating
 any condition once it determines if the condition is true or not.
 For instance in the <font color="#006699">if-statement</font>:
<pre><font color="#0000FF">        if </font><font color="#330033">x > 20 </font><font color="#0000FF">and </font><font color="#330033">y = 0 </font><font color="#0000FF">then</font>
<font color="#330033">            ...</font>
<font color="#0000FF">        end if</font>
</pre>
 The "y = 0" test will only be made when "x > 20" is true.
 <p>
 For maximum speed, you can order your tests. Do "x > 20" first if it is
 more likely to be false than "y = 0". 
 <p>
 In general, with a condition "A and B", Euphoria will not evaluate the 
 expression B, when A is false (zero). Similarly, with a condition like 
 "A or B", B will not be evaluated when A is true (non-zero).
 <p>
 Simple if-statements are highly optimized. 
 With the current version of the interpreter, 
 nested simple if's that compare integers are usually a bit faster 
 than a single short-circuit if-statement e.g.:
<pre><font color="#0000FF">       if </font><font color="#330033">x > 20 </font><font color="#0000FF">then</font>
<font color="#0000FF">           if </font><font color="#330033">y = 0 </font><font color="#0000FF">then</font>
<font color="#330033">               ...</font>
<font color="#0000FF">           end if</font>
<font color="#0000FF">       end if</font>
</pre>

<p>
<li>
 The speed of access to private variables, local variables and global
 variables is the same.
<p>
<li>
 There is no performance penalty for defining constants versus plugging
 in hard-coded literal numbers. The speed of:
<pre><font color="#330033">           y = x * MAX</font>
</pre>
 is exactly the same as:
<pre><font color="#330033">           y = x * 1000</font>
</pre>
 where you've previously defined:
<pre><font color="#0000FF">           constant </font><font color="#330033">MAX = 1000</font>
</pre>

<li>
 There is no performance penalty for having lots of comments in your 
 program. Comments are completely ignored. They are not executed in any way.
 It might take a few milliseconds longer for the initial load of your
 program, but that's a very small price to pay for future maintainability,
 and when you <font color="#993333"><b>bind</b></font> your program, 
 or <font color="#993333"><b>translate</b></font> your program to C,
 all comments are stripped out, so the cost becomes absolute zero.

</ul>

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Measuring Performance

</font>
<p>
 In any programming language, and especially in Euphoria,
 <font color="#006633"><b>you really have to make measurements before
 drawing conclusions about performance</b></font>.
<p>
 Euphoria provides both <font color="#993333"><b>execution-count
 profiling</b></font>, as well as
 <font color="#993333"><b>time profiling</b></font>
 (<font color="#CC3366"><b>DOS32</b></font> only). See
 <a class="blue" href="refman_3.htm#2"><b>refman.doc</b></a>.
 You will often be surprised by the results of these profiles. Concentrate
 your efforts on the places in your program that are using a high percentage
 of the total time (or at least are executed a large number of times.)
 There's no point to rewriting a section of code that uses 0.01% of the total
 time. Usually there will be one place, or just a few places where code
 tweaking will make a significant difference.
<p>
 You can also measure the speed of code by using the
 <font color="#006699"><b>time()</b></font> function. e.g.
<pre><font color="#FF00FF">        atom </font><font color="#330033">t</font>
<font color="#330033">        t = </font><font color="#FF00FF">time</font><font color="#330033">()</font>
<font color="#0000FF">        for </font><font color="#330033">i = 1 </font><font color="#0000FF">to </font><font color="#330033">10000 </font><font color="#0000FF">do</font>
<font color="#FF0055">            -- small chunk of code here</font>
<font color="#0000FF">        end for</font>
<font color="#330033">        ? </font><font color="#FF00FF">time</font><font color="#330033">() - t</font>
</pre>
<p>
 You might rewrite the small chunk of code in different ways to see which way 
 is faster.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

How to Speed-Up Loops

</font>
<p>
 <font color="#993333"><b>Profiling</b></font> will show you the
 <font color="#CC0099"><b><i>hot spots</i></b></font> in your program.
 These are usually inside loops. Look at each calculation inside the loop
 and ask yourself if it really needs to happen every time through the loop,
 or could it be done just once, prior to the loop.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Converting Multiplies to Adds in a Loop

</font>
<p>
 Addition is faster than multiplication. Sometimes you can replace a
 multiplication by the loop variable, with an addition. Something like:
<pre><font color="#0000FF">        for </font><font color="#330033">i = 0 </font><font color="#0000FF">to </font><font color="#330033">199 </font><font color="#0000FF">do</font>
<font color="#FF00FF">            poke</font><font color="#330033">(screen_memory+i*320, 0)</font>
<font color="#0000FF">        end for</font>
</pre>
 
 becomes:
<pre><font color="#330033">        x = screen_memory</font>
<font color="#0000FF">        for </font><font color="#330033">i = 0 </font><font color="#0000FF">to </font><font color="#330033">199 </font><font color="#0000FF">do</font>
<font color="#FF00FF">            poke</font><font color="#330033">(x, 0)</font>
<font color="#330033">            x = x + 320 </font>
<font color="#0000FF">        end for</font>
</pre>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Saving Results in Variables

</font>
<ul>
<li>
 It's faster to save the result of a calculation in a variable, than it is to
 recalculate it later. Even something as simple as a subscript operation, 
 or adding 1 to a variable is worth saving.
<p>
<li>
 When you have a sequence with multiple levels of subscripting,
 it is faster to change code like:
<pre><font color="#0000FF">           for </font><font color="#330033">i = 1 </font><font color="#0000FF">to </font><font color="#330033">1000 </font><font color="#0000FF">do</font>
<font color="#330033">               y[a][i] = y[a][i]+1</font>
<font color="#0000FF">           end for</font>
</pre>

 to:
<pre><font color="#330033">           ya = y[a]</font>
<font color="#0000FF">           for </font><font color="#330033">i = 1 </font><font color="#0000FF">to </font><font color="#330033">1000 </font><font color="#0000FF">do</font>
<font color="#330033">               ya[i] = ya[i] + 1</font>
<font color="#0000FF">           end for</font>
<font color="#330033">           y[a] = ya</font>
</pre>

 So you are doing 2 subscript operations per iteration of the loop, rather 
 than 4. The operations, ya = y[a] and y[a] = ya are very cheap.
 <font color="#006633"><b>They just copy a pointer.</b></font> They
 don't copy a whole sequence.
<p>
<li>
 There is a slight cost when you create a new sequence using <b>{a,b,c}</b>.
 If possible, move this operation out of a critical loop by storing it 
 in a variable before the loop, and referencing the variable inside the
 loop.

</ul>

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

In-lining of Routine Calls

</font>
<p>
 If you have a routine that is rather small and fast, but is called a huge 
 number of times, you will save time by doing the operation
 <b><i>in-line</i></b>, rather than calling the routine. Your code may
 become less readable, so it might be better to in-line only at places that
 generate a lot of calls to the routine.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Operations on Sequences

</font>
<p>
 Euphoria lets you operate on a large sequence of data using a single
 statement. This saves you from writing a loop where you process one element
 at-a-time. e.g.
<pre><font color="#330033">        x = {1,3,5,7,9}</font>
<font color="#330033">        y = {2,4,6,8,10}</font>
<font color="#330033"></font>
<font color="#330033">        z = x + y</font>
</pre>

 versus:
<pre><font color="#330033">        z = </font><font color="#FF00FF">repeat</font><font color="#330033">(0, 5)  </font><font color="#FF0055">-- if necessary</font>
<font color="#0000FF">        for </font><font color="#330033">i = 1 </font><font color="#0000FF">to </font><font color="#330033">5 </font><font color="#0000FF">do</font>
<font color="#330033">            z[i] = x[i] + y[i]</font>
<font color="#0000FF">        end for</font>
</pre>
<p>
 In most interpreted languages, it is much faster to process a whole sequence 
 (array) in one statement, than it is to perform scalar operations
 in a loop. This is because the 
 interpreter has a large amount of overhead for each statement it executes.
 Euphoria is different. Euphoria is very lean, with little 
 interpretive overhead, so operations on sequences don't always win. 
 The only solution is to time it both ways. The per-element cost is usually
 lower when you process a sequence in one statement, but there are overheads 
 associated with allocation and deallocation of sequences that 
 may tip the scale the other way.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Some Special Case Optimizations

</font>
<p>
 Euphoria automatically optimizes certain special cases. x and y below could 
 be variables or arbitrary expressions.
<pre><font color="#330033">        x + 1      </font><font color="#FF0055">-- faster than general x + y</font>
<font color="#330033">        1 + x      </font><font color="#FF0055">-- faster than general y + x</font>
<font color="#330033">        x * 2      </font><font color="#FF0055">-- faster than general x * y</font>
<font color="#330033">        2 * x      </font><font color="#FF0055">-- faster than general y * x</font>
<font color="#330033">        x / 2      </font><font color="#FF0055">-- faster than general x / y</font>
<font color="#FF00FF">        floor</font><font color="#330033">(x/y) </font><font color="#FF0055">-- where x and y are integers, is faster than x/y</font>
<font color="#FF00FF">        floor</font><font color="#330033">(x/2) </font><font color="#FF0055">-- faster than floor(x/y)</font>
</pre>
<p>
 x below is a simple variable, y is any variable or expression: 
<pre><font color="#330033">        x = </font><font color="#FF00FF">append</font><font color="#330033">(x, y)   </font><font color="#FF0055">-- faster than general z = append(x, y)</font>
<font color="#330033">        x = </font><font color="#FF00FF">prepend</font><font color="#330033">(x, y)  </font><font color="#FF0055">-- faster than general z = prepend(x, y)</font>
<font color="#330033"></font>
<font color="#330033">        x = x & y          </font><font color="#FF0055">-- where x is much larger than y,</font>
<font color="#FF0055">                           -- is faster than general z = x & y</font>
</pre>

When you write a loop that "grows" a sequence, by appending or
concatenating data onto it, the time will, in general, grow in proportion
to the <b>square</b> of the number (N) of elements you are adding.
However, if you can use one of the special optimized forms of append(),
prepend() or concatenation listed above, the time will grow in proportion
to just N (roughly). This could save you a <b>huge</b> amount of time
when creating an extremely long sequence.
(You could also use repeat() to establish the maximum size
of the sequence, and then fill in the elements in a loop, as discussed
below.)
<p>
<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Assignment with Operators

</font>
<p>
 For greater speed, convert:
<pre>
        <b>left-hand-side = left-hand-side op expression</b>
</pre>
 to:
<pre>
        <b>left-hand-side op= expression</b>
</pre>
 
 whenever left-hand-side contains at least 2 subscripts, or at least
 one subscript and a slice. In all simpler cases the two forms run at 
 the same speed (or very close to the same).

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Pixel-Graphics Tips

</font>
<ul>
<li>
 Mode 19 is the fastest mode for
 <font color="#009999"><b>animated graphics</b></font> and
 <font color="#009999"><b>games</b></font>.
<p>
<li>
 The video memory (in mode 19) is not cached by the CPU. It usually takes longer
 to read or write data to the screen than to a general area of memory that
 you allocate. This adds to the efficiency of
 <font color="#CC0099"><b><i>virtual</i></b> <b>screens</b></font>, where
 you do all of your image updating in a <b>block of memory</b> that you
 get from <font color="#006699"><b>allocate()</b></font>, and then you
 periodically <font color="#006699"><b>mem_copy()</b></font> the resulting
 image to the real <b>screen memory</b>. In this way you never have to
 read the (slow) screen memory.
<p>
<li>
 When plotting pixels, you may find that modes 257 and higher are fast near
 the top of the screen, but slow near the bottom.

</ul>

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Text-Mode Tips

</font>
<p>
 Writing text to the screen using <font color="#006699"><b>puts()</b></font>
 or <font color="#006699"><b>printf()</b></font> is rather slow.
 If necessary, in <font color="#CC3366"><b>DOS32</b></font>, you can do it much faster by poking into the
 <b>video memory</b>, or by using
 <font color="#006699"><b>display_text_image()</b></font>. There is a very
 large overhead on each puts() to the screen, and a relatively small
 incremental cost per character. The overhead with
 <font color="#993333"><b>exw</b></font> (WIN32) is especially high (on Windows 95/98/ME
 at least). Linux and FreeBSD are somewhere between DOS32 and WIN32 
 in text output speed. It therefore makes sense
 to build up a long string before calling puts(), rather than calling it 
 for each character. There is no advantage to building up a string 
 longer than one line however. 
 <p>
 The slowness of text output is mainly due to operating system overhead. 

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Library Routines

</font>
<p>
 Some common routines are extremely fast. You probably couldn't do the job 
 faster any other way, even if you used C or assembly language. Some of these 
 are:
<ul>
<li>
 <font color="#006699"><b>mem_copy()</b></font>
<li>
 <font color="#006699"><b>mem_set()</b></font>
<li>
 <font color="#006699"><b>repeat()</b></font>
</ul>
<p>
 Other routines are reasonably fast, but you might be able
 to do the job faster in some cases if speed was crucial.
<pre><font color="#330033">        x = </font><font color="#FF00FF">repeat</font><font color="#330033">(0,100)</font>
<font color="#0000FF">        for </font><font color="#330033">i = 1 </font><font color="#0000FF">to </font><font color="#330033">100 </font><font color="#0000FF">do</font>
<font color="#330033">            x[i] = i</font>
<font color="#0000FF">        end for</font>
</pre>
 
 is somewhat faster than:
<pre><font color="#330033">        x = {}</font>
<font color="#0000FF">        for </font><font color="#330033">i = 1 </font><font color="#0000FF">to </font><font color="#330033">100 </font><font color="#0000FF">do</font>
<font color="#330033">            x = </font><font color="#FF00FF">append</font><font color="#330033">(x, i)</font>
<font color="#0000FF">        end for</font>
</pre>

 because <font color="#006699">append()</font> has to allocate and reallocate
 space as x grows in size. With <font color="#006699">repeat()</font>, the
 space for x is allocated once at the beginning. (append() is smart enough
 not to allocate space with <b><i>every</i></b> append to x.
 It will allocate somewhat more than it needs, to reduce the number of
 reallocations.)
<p>
 You can replace:
<pre><font color="#FF00FF">        remainder</font><font color="#330033">(x, p)</font>
</pre>
 
 with:
<pre><font color="#FF00FF">        and_bits</font><font color="#330033">(x, p-1)</font>
</pre>

 for greater speed when p is a positive power of 2. x must be a non-negative
 integer that fits in 32-bits.
<p>
 <font color="#006699"><b>arctan()</b></font> is faster than
 <font color="#006699"><b>arccos()</b></font> or
 <font color="#006699"><b>arcsin()</b></font>.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Searching

</font>
<p>
 Euphoria's <font color="#006699"><b>find()</b></font> is the fastest way
 to search for a value in a sequence up to about 50 elements. Beyond that,
 you might consider a <i>hash table</i>
 (<font color="#5500FF"><b>demo\hash.ex</b></font>) or a
 <i>binary tree</i> (<font color="#5500FF"><b>demo\tree.ex</b></font>).

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Sorting

</font>
<p>
 In most cases you can just use the <i>shell sort</i> routine in
 <font color="#5500FF"><b>include\sort.e</b></font>. 
<p>
 If you have a huge amount of data to sort, you might try one of the sorts 
 in <font color="#5500FF"><b>demo\allsorts.e</b></font> (e.g.
 <i><b>great</b> sort</i>). If your data is too big to fit in 
 memory, don't rely on Euphoria's automatic memory swapping capability. 
 Instead, sort a few thousand records at a time, and write them out to a 
 series of temporary files. Then merge all the sorted temporary files into 
 one big sorted file. 
<p>
 If your data consists of integers only, and they are all in a fairly 
 narrow range, try the <i>bucket sort</i> in
 <font color="#5500FF"><b>demo\allsorts.e</b></font>.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Taking Advantage of Cache Memory

</font>
<p>
 As CPU speeds increase, the gap between the speed of the on-chip cache 
 memory and the speed of the main memory or DRAM (dynamic random access memory)
 becomes ever greater. You might have 256 Mb of DRAM on your computer, but the 
 on-chip cache is likely to be only 8K (data) plus 8K (instructions) on a 
 Pentium, or 16K (data) plus 16K (instructions) on a Pentium with MMX or a
 Pentium II/III. Most machines will also have a "level-2" cache of 256K or 512K.
<p>
 An algorithm that steps through a long sequence of a couple of thousand
 elements or more, many times, from beginning to end, performing one 
 small operation on each element, will not make good use of the on-chip data 
 cache. It might be better to go through once, applying several operations to 
 each element, before moving on to the next element. The same argument holds 
 when your program starts swapping, and the least-recently-used data is moved 
 out to disk.
<p>
 These cache effects aren't as noticeable in Euphoria as they are in
 lower-level compiled languages, but they are measurable.

<p>

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>

Using Machine Code and C

</font>
<p>
 Euphoria lets you call routines written in 32-bit Intel machine code. On
 <font color="#CC3366"><b>WIN32</b></font> and
 <font color="#CC3366"><b>Linux</b></font> and
 <font color="#CC3366"><b>FreeBSD</b></font> 
 you can call C routines in
 <b>.</b>dll or <b>.</b>so files, and these C routines can call your Euphoria routines.
 You might need to call C or machine code because of something that can't be
 done directly in Euphoria, or you might do it for improved speed.
<p>
 To boost speed, the machine code or C routine needs to do a significant 
 amount of work on each call, otherwise the overhead of setting up the 
 arguments and making the call will dominate the time, and it might not 
 gain you much.
<p>
 Many programs have some inner core operation that consumes most of the
 CPU time. If you can code this in C or machine code, while leaving the
 bulk of the program in Euphoria, you might achieve a speed comparable
 to C, without sacrificing Euphoria's safety and flexibility.

<p>&nbsp;

<font face="Arial, Helvetica" color="#FF0099" size=+1>
<br>
Using The Euphoria To C Translator
</font>

<p>
In version 3.0, the full 
Euphoria To C Translator is included in the installation package.
It will translate any Euphoria program into a set of C source
files that you can compile using a C compiler. 
<p>
The executable file that you get using the Translator should run the same,
but faster than when you use the interpreter. The speed-up can be anywhere
from a few percent to a factor of 5 or more.


<p>&nbsp;

</td></tr></table>

</body>
</html>
